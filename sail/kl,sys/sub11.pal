COMMENT ⊗   VALID 00047 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00005 00002	.SBTTL	BASIC INITIALIZATION ROUTINE, 19-AUG-75
C00012 00003	.SBTTL	SET EOP INTERVAL TALLY, ERROR EOP
C00015 00004	.SBTTL	ERROR HALT
C00018 00005	.SBTTL	PRINT ASCIZ MESSAGE (PNTAL)
C00020 00006	.SBTTL	PRINT BUFFER LOAD ROUTINE
C00022 00007	.SBTTL	TELETYPE PRINT OUTPUT ROUTINE
C00024 00008	.SBTTL	TELETYPE DRIVER
C00028 00009	.SBTTL	LINE PRINTER DRIVER
C00032 00010	OPERATOR INTERRUPT TYPEIN CHECKS
C00034 00011	.SBTTL	PRINT CRLF
C00036 00012	.SBTTL	PRINT LOWER 18 BITS OF 36 BIT NUMBER
C00038 00013	$PRT36:	MOV	4(R1),R0	GET THE WORD
C00040 00014	.SBTTL	PRINT OCTAL
C00042 00015	.SBTTL	CONVERT BINARY TO DECIMAL AND TYPE ROUTINE
C00045 00016	.SBTTL	TTY INPUT ROUTINE TTICHR
C00047 00017	.SBTTL	TTIYES YES OR NO ROUTINE
C00048 00018	.SBTTL	READ SWITCH REGISTER
C00050 00019	.SBTTL	INPUT A STRING FROM TTY
C00052 00020	82$:	CMPB	(R1),#141
C00054 00021	SPECIAL CHAR PROCESS
C00056 00022	SPECIAL CHARACTERS
C00057 00023	.SBTTL	CTY & FSTTY DL11 DRIVERS
C00060 00024	.SBTTL	READ AN OCTAL NUMBER FROM THE TTY
C00062 00025	.SBTTL	READ A DECIMAL NUMBER FROM THE TTY
C00064 00026	.SBTTL	READ A 12 DIGIT OCTAL (36 BIT) NUMBER
C00066 00027	3$:	MOV	R5,$INPTC	RESET INPUT POINTER
C00068 00028	8$:	TSTB	$0FLG
C00070 00029	.SBTTL	SIGNED MULTIPLY SUBROUTINE
C00072 00030	.SBTTL	BREAK CHARACTER
C00074 00031	.SBTTL	TELETYPE INPUT TERMINATION CHECK
C00076 00032	.SBTTL	INPUT & CHECK OCTAL NUMBER
C00077 00033	.SBTTL	SHIFT R0 RIGHT/LEFT ROUTINES
C00079 00034	.SBTTL	SMALL TIME DELAY
C00080 00035	FATAL VECTOR INTERRUPT
C00081 00036	.SBTTL	EMT DECODER
C00083 00037		$PNTNBR		EMT + 30
C00085 00038		$DPSVT		EMT + 110
C00087 00039		$RPLKUP		EMT + 170
C00089 00040	.SBTTL	POWER DOWN AND UP ROUTINES
C00092 00041	.SBTTL	EXIT SUBROUTINE
C00093 00042	.SBTTL	PDP10 OPERATIONS
C00100 00043	$D10ADR:MOV	#L10ADR,R4
C00103 00044	START MICROCODE
C00104 00045	PDP-10 INSTRUCTION EXECUTE
C00105 00046	PDP-10 CONTROLLED STOP ROUTINE
C00107 00047		.SBTTL	CLOCK INITIALIZATION, INTERRUPTS
C00110 ENDMK
C⊗;
.SBTTL	BASIC INITIALIZATION ROUTINE, 19-AUG-75

;*THIS SUBROUTINE PERFORMS THE MOST ELEMENTARY SET UP FOR THE CPU
;*THIS ROUTINE MUST BE EXECUTED BY ALL OF THE POSSIBLE START
;*OPTIONS PRIOR TO ANY OTHER SUBROUTINE

$$ILOAD:MOV	#STACK,SP			;START HERE FIRST TIME
	MOV	#<<.DELAY-$ILDCLR>/2>,R1
	MOV	#$ILDCLR,R0
1$:	CLR	(R0)+		;CLEAR SPECIAL CONTROL WORDS
	DEC	R1
	BGT	1$
	MOV	#17,CLKDFL+4	;INITIAL DEFAULT, ALL 4 CACHES
	MOV	#36,PEBITS	;INITIAL DEFAULT, AR/ARX, FM, CRAM, DRAM
				;AND NOT FS PROBE, PARITY STOP ENABLES
	JSR	PC,$CKSUM	;CHECKSUM "KLDCP"
	MOV	R0,$ILDSUM	;SAVE

$SBRINT:MOV	#CPUPR,PS	;SET CPU PRIORITY	;NORMAL START (100000)
	MOV	#STACK,SP	;SET THE STACK POINTER

.IF DF %%DDT
;	MOV	#CPUPR,%DDTS	;CPU PRIORITY FOR DDT
	MOV	@#14,-(SP)	;PUSH 14 AND 16
	MOV	@#16,-(SP)	;TO ALLOW DDT BREAKPOINT TRAPS
.ENDC

.IF DF %%QMP
	MOV	776,R1		;Save location 776
.ENDC

	CLR	R0		;SET ENTIRE VECTOR AREA TO:
1$:	MOV	#$FATLE,(R0)+	;	;ADDRESS OF ERROR HANDLER
	MOV	#PR7,(R0)+	;	;PR7
	CMP	R0,#1000
	BLT	1$

.IF DF %%QMP
	CMP	R1,(PC)+	;did 776 contain JMP (R0)?
	JMP	(R0)		;if so, we were started by WAITS
	BNE	99$		;and must go into monitor mode.
	BIS	#100000,776	;set sign bit in 776.
99$:
.ENDC

	MOV	#$TIMOT,@#ERRVEC ;TIME OUT BUS ERROR VECTOR
	MOV	#$RESVD,@#RESVEC ;RESERVED INSTRUCTION VECTOR
	MOV	#$PWRDN,@#PWRVEC ;POWER FAIL VECTOR

.LIF DF BPTASB
	MOV	#$BRKPT,@#IOTVEC ;IOT VECTOR

	MOV	#$EMTRP,@#EMTVEC ;EMT VECTOR

.IF DF %%DDT
	MOV	(SP)+,@#16	;FOR DDT, POP BREAKPOINT TRAP
	MOV	(SP)+,@#14
.IFF
	MOV	#.BCCT,@#BPTVEC	;SET BP VECTOR
.ENDC

.IF DF SAILVR
	JSR	PC,CLKSTA		;CLOCK START (AFTER CLOBBERING INTERRUPTS)
	MOV	#CPUPR,@#EMTVEC+2	;SO EMTS DON'T AFFECT PROCESSOR PRIORITY
.ENDC

.IF DF TELASB
	MOV #DLRTS,@$FSTKS		;INITIALIZE
	MOV #FSRINT,@$FSTRV		;SETUP FS KL11E RECEIVE TRAP VECTOR
	MOV #FSTINT,@$FSTTV		;SETUP FS KL11E TRANSMIT TRAP VECTOR
	MOV #40000.,R0			;40000*2.36USEC = 94.4 MS
	SOB R0,.			;WAIT FOR DATA SET TO HANG UP
	BIS #DLRTS!DLDTR!DLDIE,@$FSTKS	;SET DATA TERM READY AND DATA SET INT ENB
		;LEAVE REQUEST TO SEND UP ALTHOUGH WE DON'T USE IT
.ENDC ;IF DF TELASB

.IF DF CLKASB
	MOV #TCUINT,@$CLKTV		;SET UP TCU-100 TRAP VECTOR
.ENDC ;IF DF CLKASB

11$:	MOV	#BUFCLR,R0	;CLEAR BUFFER STORAGE BETWEEN:
21$:	CLR	(R0)+		;BUFCLR: AND .DELAY !
	CMP	R0,#$ILDCLR
	BNE	21$
	MOV	SP,$KONSP

	CLR	CONSOL-2

	TTPINI			;RESET TTY POINTERS

	MOV	#132.,$PGWID	;SET PAGE WIDTH PARAMETER (LA36!)
	MOV	#0,$TTYFL	;SET FILL PARAMETER TO (LA36!)
	PFORCE			;MUST TYPE STARTUP
	MOV	#NOPAR,ERRVEC	;SET BUS TIMEOUT IN CASE NO PARITY
	MOV	#MEMPE,MMLPIV	;SETUP PARITY VECTOR
	MOV	#MMPIE,MMLPBA	;ENABLE PARITY ERRORS
	MOV	#$TIMOT,ERRVEC	;RESTORE BUS TIMEOUT

	TST	$ONETM
	BNE	3$

.LIF DF BPTASB
	JSR	PC,.CB		;CLEAR BP'S

.IF DF SAILVR
	PMSG	<\Stanford KLDCP - QMP/EN\>
	MOV	#SWS10,R0	;setup initial switches to 3,,600000
	CLR	(R0)+		;bits 20:35
	BIS	#17,(R0)+	;bits 04:19
	CLR	(R0)		;bits 0:3
.IFF
	PMSG	<\DECSYSTEM10 DIAGNOSTIC CONSOLE\VERSION >
	MOV	#MCNVER,R0
	PNTOCS
	PNTCI
	'.
	MOV	#DECVER,R0
	PNTOCS
;.IF DF SAILVR
;	PMSG	<, Stanford version >
;	MOV	#SAILVR,R0
;	PNTOCS
;.ENDC
	PMSG	<\11 SWR = >
	MOV	SWR,R0
	PNTOCT			;PRINT CONSOLE SWITCHES
	PCRLF
.ENDC

3$:	JSR	PC,DTEINI	;DTE20 INITIALIZATION

.IF NDF SAILVR
	TST	DEVTYP		;USING RP04 ?
	BLE	4$		;NO
	RPLOAD			;YES, INIT & LOAD PACK
	 BCC	4$
	RPERROR			;FAILED
.ENDC

4$:
.IF DF %%QMP
	TST	776		;were we loaded and started by the 10?
	BGE	44$		;branch if not
	SETFLG
	  MONMODE
	SETFLG
	  TENRUN
	SETFLG
	  PRGRUN
	SETFLG
	  MTTYOF
.ENDC
	
44$:
.LIF DF %%QMP
	JSR	PC,QMPINI	;initialize QMP

	JMP	CONSL		;NOW TO CONSOLE

NOPAR:	RTI			;NO PARITY REGISTER

$CMCLR:	MOV	#$CMTAG,R0	;CLEAR COMMON STORAGE
1$:	CLR	(R0)+
	CMP	R0,#MONCTL
	BLT	1$
	RTS	PC

$CKSUM:	CLR	$KDCEN		;CLEAR ONLY CHANGEABLE LOCATION
	MOV	#START,R1
	CLR	R0
2$:	ADD	(R1)+,R0	;CHECKSUM "KLDCP"
	CMP	R1,$$FF
	BLOS	2$
	RTS	PC
.SBTTL	SET EOP INTERVAL TALLY, ERROR EOP
.IF NDF %%EOP

$EOPSET:
$EOP:
$ERREOP:FATAL
.ENDC

.IF DF %%EOP
$EOPSET:MOV	R0,$ENDCT	;SET EOP INTERVAL TALLY
	EXIT

;CONSOLE SET EOP INTERVAL

.EP:	TTISDL
	 BCS	1$
	TTIDEC			;SPECIFIED AS DECIMAL INTERVAL
	 BCS	1$
	MOV	R0,$ENDCT
	CLR	$EOPCT
	JMP	$KONSL
1$:	JMP	$PARAM

.SBTTL	END OF PASS ROUTINE

$EOP:	MOV	#$PASS,R5
	INC	(R5)		;INCREMENT THE PASS NUMBER
	CMP	(R5),#30001.	;LIMIT MAX COUNT TO 30000
	BLT	4$
	CLR	(R5)
	INC	(R5)
	MOV	$ENDCT,$EOPCT	;RESET REPORT INTERVAL

4$:	MOV	(R5),SWR	;DISPLAY PASS COUNT
	SWITCH			;READ THE SWITCH REGISTER

	BIT	R0,#ABORT	;ABORT AFTER CURRENT PASS?
	BNE	1$		;YES

	DEC	$EOPCT		;DECREMENT EOP
	BGT	3$
	BR	2$

1$:	MOV	#1,$ITERA	;SET ITERATION SO WE WILL EXIT
2$:	PMSG	<END PASS >

	MOV	(R5),R0		;PASS COUNT TO  R0
	PNTDEC
	PCRLF

	MOV	$ENDCT,$EOPCT	;RESTORE COUNTER

3$:	DEC	$ITERA		;DECREMENT ITERATION COUNT
	BEQ	$ERREOP
	CLR	$ITERA
	EXIT

$ERREOP:TST	MONCTL		;STAND ALONE ?
	BNE	$EROP		;NO, *WHAT TO DO ??*
	CLR	TENRUN		;TURN OFF TEN SUPPORT
	CLR	PRGRUN		;YES, ALLOW "J" AGAIN

$EROP:	JMP	CONSL		;MONITOR, TO NEXT SCRIPT ENTRY

.ENDC
.SBTTL	ERROR HALT

$PRGHLT:PUSH	R0
	PMSG	<\PRG>
	BR	$PH2

$ERRHLT:PUSH	R0
	SWITCH
	BIT	R0,#ERSTOP	;STOP ON ERROR ?
	BNE	1$		;YES
	POP	R0
	EXIT			;NO, KEEP GOING

1$:	PMSG	<\ERROR>

$PH2:	SETFLG
	  .HCFLG		;ALLOW HALT CONTINUE

$PH1:	MOV	(SP)+,$R0SAV	;SETUP SO "RG" CAN PRINT
	MOV	#$R5SAV+2,R0
	MOV	(SP)+,-(R0)	;R5 to $R5SAV
	MOV	(SP)+,-(R0)	;R4 to $R4SAV
	MOV	(SP)+,-(R0)	;R3 to $R3SAV
	MOV	(SP)+,-(R0)	;R2 to $R2SAV
	MOV	(SP)+,-(R0)	;R1 to $R1SAV
	MOV	(SP)+,.HCADR	;halt/continue address (if needed)
	MOV	(SP)+,$PSSAV	;halt/continue PS.
	MOV	SP,$SPSAV	;save dead SP
	PMSG	< HALT AT >
	MOV	.HCADR,R0	;GET ADDRESS
	SUB	#2,R0		;COMPUTE ACTUAL ADDRESS
	PNTOCT			;PRINT ERROR HALT ADDRESS
	PCRLF
	PFORCE
	CLR	R2		;REGISTER NUMBER
	MOV	#$R0SAV,R1	;REG SAVE TABLE POINTER
1$:	PNTCI
	'R
	MOV	R2,R0		;register number
	PNTNBR			;PRINT REGISTER NUMBER
4$:	PSLASH
2$:	MOV	(R1)+,R0
	PNTOCT			;PRINT CONTENTS
	PCRLF
	INC	R2
	CMP	R2,#6
	BLT	1$		;loop for zero to 5
	BGT	3$		;exit for 7
	PNTCI
	"SP
	BR	4$		;print R6 as SP

3$:	CLR	R2		;Count of stack frames
	MOV	$SPSAV,R1	;Stack top address
91$:	MOV	R1,R0
	PNTOCT
	PSLASH
	MOV	(R1)+,R0
	PNTOCT			;PRINT CONTENTS
	PCRLF
	CMP	R1,#COREND
	BGE	92$
	INC	R2
	CMP	R2,#6
	BLT	91$		;loop to display several stack items
92$:	TST	.HCFLG		;is this a continuable halt?
	BEQ	93$		;BR if not
	JMP	$CONSL		;RETURN TO MONITOR

93$:
.LIF DF %%DDT
	JMP	56000

.LIF NDF %%DDT
	JMP	$SBRINT		;major crash.  nearly major reload

.HC:	TST	.HCFLG
	BNE	1$
	JMP	$CMDER		;HC NOT ALLOWED
1$:	CLR	.HCFLG

.LIF DF BPTASB
	JSR	PC,.BCHC

	MOV	$SPSAV,R6
	MOV	$PSSAV,PS
	JMP	@.HCADR
.SBTTL	PRINT ASCIZ MESSAGE (PNTAL)

$PNTAL:	BICB	#200,(R0)	;CLEAR JUNK
	TSTB	(R0)		;REACHED EOL YET?
	BEQ	3$		;YES
	TST	HLPPNT		;PRINTING A HELP FILE
	BNE	4$		;YES
	CMPB	(R0),#BKARW	;BACKARROW (-)?
	BEQ	2$		;YES
	CMPB	(R0),#BKSLH	;BACKSLASH (\)?
	BEQ	1$
4$:	MOVB	(R0)+,R1	;PUT CHAR IN R1
	PLDBUF			;LOAD INTO OUTPUT BUFFER
	BR	$PNTAL		;DO TILL E-O-L

1$:	MOV	#CR,R1		;BACKSLASH
	PLDBUF			;OUTPUT CR & LF
	MOV	#LF,R1
	PLDBUF
11$:	INC	R0
	BR	$PNTAL

2$:	CLR	CTRLOF		;CLEAR CONTROL O FLAG
	PRINTT			;BACKARROW, PRINT BUFFER
	BR	11$

3$:	BR	$$PNTX

.SBTTL	PRINT ASCII NUMBER (PNTNBR)

$PNTNBR:BIC	#177770,R0
	BIS	#'0,R0

.SBTTL	PRINT ASCII CHARACTER (PNTCHR)

$PNTCHR:MOVB	R0,R1
	PLDBUF
$$PNTX:	EXIT

$PSPACE: MOV	#SPACE,R0
	BR	$PNTCHR

$PSLASH: MOV	#SLASH,R0
	BR	$PNTCHR

$PCOMMA: MOV	#COMMA,R0
	BR	$PNTCHR

$PTAB:	MOV	#TAB,R0
	BR	$PNTCHR
.SBTTL	PRINT BUFFER LOAD ROUTINE

$PLDBUF:PUSH	R0
	MOV	$OUTPT,R0
	BIC	#177600,R1	;STRIP TO 7 BITS
	MOVB	R1,(R0)+	;PUT CHAR IN BUFFER
	CLRB	(R0)		;INSERT TRAILING NULL
	MOV	R0,$OUTPT
	POP	R0
	CMP	$OUTPT,#$OUTBF+140.;EXCEEDED BUFFER CAPACITY
	BGE	2$

1$:	CMPB	#LF,R1		;WAS CHAR LINE FEED
	BEQ	2$		;YES
	CMPB	#BELL,R1	;WAS CHAR BELL ?
	BEQ	2$		;YES
	CMPB	#NULL,R1	;WAS CHAR NULL ?
	BEQ	2$		;YES
3$:	BR	$$PNTX		;NO, RETURN

2$:	TST	PCMDNF		;DOING NO PRINT PROGRAM COMMAND
	BNE	3$

.LIF DF LPTASB
	PLPT			;LINE PRINTER

	PRINTT			;PRINT BUFFER
	CLR	$TTLKF		;CLEAR TTLOOK  FLAG
	PUSH	R0
	PNTRST			;RESET OUTPUT POINTERS
	POP	R0
	BR	3$

;PRINT, BACKUP OUTPUT INSERTION POINTER

$PNTBAK:CMP	$OUTPT,#$OUTBF	;ALL THE WAY BACK ?
	BLE	1$		;YES
	DEC	$OUTPT		;NO, BACKUP ONE BYTE
1$:	BR	$$PNTX

;TELETYPE POINTER INITIALIZATION

$TTPINI:MOV	#$INBUF,$INPTC
	MOV	#$INBUF,$INPTR

$PNTRST:MOV	#$OUTBF,R0
	MOV	R0,$OUTPT
	MOV	R0,$OUTPP
	BR	$$PNTX
.SBTTL	TELETYPE PRINT OUTPUT ROUTINE

$PRINT:	PUSH	R0
	TST	$FORCE		;FORCED PRINT OUT
	BNE	19$		;YES BYPASS SWITCH TEST

	TSTB	LPTFLG		;PRINT ON LPT ?
	BNE	99$		;BR IF YES

	SWITCH
	BIT	R0,#NOPNT	;PRINTOUT INHIBITED
	BEQ	1$

99$:	MOV	$OUTPT,$OUTPP	;DONE, SET PRINTED TO POSITION
	POP	R0
	BR	$$PNTX		;RETURN

19$:	CLR	CTRLOF		;CLEAR CONTROL O FLAG
1$:	MOV	$OUTPP,R1

11$:	CMPB	#CR,(R1)	;IS CHAR CR?
	BEQ	2$		;BR IF YES
	CMP	$PRNTH,$PGWID	;NO,ARE WE AT RIGHT MARGIN
	BLT	3$		;BR IF NO
	MOVB	#CR,R0		;YES, FREE CR/LF
	PTTY
	MOVB	#LF,R0
	PTTY

2$:	INC	$TPLIT		;COUNT LINE

3$:	MOVB	(R1),R0		;GET CHARACTER
	BEQ	99$		;IF NULL, DONE
	PTTY			;PRINT CHAR
	TSTB	(R1)+		;LOOP TILL E-O-L
	BNE	11$
4$:	JSR	PC,C10COP
	JSR	PC,$TORDY	;THEN WAIT FOR TTY TO BE READY
	BCS	4$
	BR	99$
.SBTTL	TELETYPE DRIVER

$PTTY:	CLR	R2
	CLR	R3
1$:	JSR	PC,$PTTYC	;DO OPERATOR CHECKS
	TST	R3		;R3 = 0 IF NOTHING
	BEQ	4$
2$:	CMPB	#XON,R3
	BEQ	6$		;XON,PRINT
	CMPB	#XOFF,R3
	BNE	4$
3$:	MOV	#-1,R2		;XOFF,STOP PRINT
4$:	TST	R2
	BNE	1$		;IF XOFF, WAIT FOR XON
6$:	TST	CTRLOF		;CONTROL O'D ?
	BNE	7$		;YES
	CMPB	#CR,R0		;CR
	BNE	7$
	TST	$TPLIN		;YES, IN PAGE MODE
	BEQ	7$		;NO
	CMP	$TPLIT,$TPLIN	;FILLED THIS PAGE
	BLT	7$
	CLR	$TPLIT		;YES,CLEAR COUNTER,XOFF
	BR	3$

7$:	CLR	R2
	CMPB	#CNTRLI,R0	;IS CHAR A TAB?
	BNE	10$
8$:	JSR	PC,$PTTY1	;COMPUTE SPACES COUNT
9$:	INC	R2		;COMPLETED "TAB"?
	MOVB	#BLANK,R0

10$:	JSR	PC,C10COP	;PERFORM CLOCK OPERATIONS
	TST	CTRLOF
	BNE	11$
	JSR	PC,$TORDY	;WAIT TILL TTY IS READY
	BCS	10$
	MOVB	R0,$TOCHR	;PRINT CHAR
	JSR	PC,$TOOUT
19$:	JSR	PC,$PTTY2	;WILL CHAR MOVE PRINT HEAD ?

11$:	TST	R2		;DOING SPACES?
	BNE	9$		;BR IF YES
	TST	CTRLOF
	BNE	15$
	MOV	#$DTBL0,R2	;FILLER PROCESS
12$:	TSTB	(R2)
	BEQ	15$		;BR IF CHAR DOESN'T REQUIRE FILLS
	CMPB	(R2)+,R0
	BNE	12$
	DEC	R2		;FOUND
	SUB	#$DTBL0,R2
	ASL	R2
	MOV	$DTBL1(R2),R2	;ADDRESS TO R2
	ADD	$TTYFL,R2	;ADD FILL PARAMETER
	MOVB	(R2),R2		;R2 = NUMBER OF FILLS
	CMPB	R0,#CR		;CR?
	BNE	13$		;NO
	CMP	$PRNTH,#15.	;MORE THEN 15 CHARS ON LINE ?
	BGT	16$
	SR	R2,1		;NO, 1/4 TH OF FILLERS THEN
16$:	CMP	$PRNTH,#40.	;MORE THAN 40 CHARS ON LINE ?
	BGT	17$
	SR	R2,1		;NO, 1/2 OF FILLERS THEN
17$:	CLR	$PRNTH		;SET PRINT HEAD TO LEFT MARGIN

13$:	DEC	R2		;COMPLETED FILLERS?
	BLT	15$
14$:	JSR	PC,C10COP	;PERFORM CLOCK OPERATIONS
	JSR	PC,$TORDY
	BCS	14$
	MOVB	#NULL,$TOCHR	;SEND FILLER
	JSR	PC,$TOOUT
	BR	13$
15$:	EXIT			;RETURN

$PTTY1:	MOV	$PRNTH,R2	;HEAD POSITION
1$:	SUB	#8.,R2		;DIVIDED BY 8
	BGE	1$		;REMAINDER IS SPACES COUNT
	RTS	PC

$PTTY2:	CMPB	R0,#BLANK	;WILL CHAR MOVE PRINT HEAD?
	BLT	1$		;BR IF NO
	INC	$PRNTH		;YES
1$:	RTS	PC
.SBTTL	LINE PRINTER DRIVER

.IF DF LPASB

$PLPT:	PUSH	R0
	TST	LPTFLG		;PRINT ON LPT ?
	BPL	99$		;NO
	TSTB	LPTFLG
	BEQ	99$
	TST	$FORCE		;FORCED PRINT ?
	BNE	1$		;YES, BYPASS SWITCH TEST
	SWITCH
	BIT	R0,#NOPNT	;PRINTOUT INHIBITED ?
	BEQ	1$		;NO
99$:	POP	R0
	EXIT			;RETURN

1$:	TST	LPTYPE		;LP20 OR LP11 ?
	BNE	50$		;LP20
	TST	@$LPS		;IS LPT OK ?
	BMI	4$		;BR IF ERROR
	MOV	#$OUTBF,R1
2$:	MOVB	(R1)+,R0	;GET CHAR
	BEQ	99$		;NULL, DONE
3$:	CLR	R2
	CMPB	#CNTRLI,R0	;TAB ?
	BNE	41$
	JSR	PC,$PTTY1	;YES, COMPUTE SPACES COUNT
42$:	INC	R2
	MOV	#BLANK,R0
41$:	JSR	PC,$PTTYC	;DO OPERATOR CHECKS
32$:	TST	@$LPS		;LPT OK ?
	BMI	4$		;NO
	JSR	PC,C10COP	;PERFORM CLOCK OPERATIONS
	TSTB	@$LPS		;LPT READY ?
	BPL	41$		;NO
	MOVB	R0,@$LPB	;PRINT CHARACTER
	JSR	PC,$PTTY2	;WILL CHAR MOVE PRINT HEAD ?
45$:	TST	R2		;COMPLETED "TAB" ?
	BNE	42$
43$:	CMPB	R0,#CR
	BNE	44$
	CLR	$PRNTH		;IF CR, RESET HEAD POSITION
44$:	BR	2$

4$:	MOV	#$LPTOF,R1	;"LPT OFF LINE"
5$:	MOVB	(R1),R0
	PTTY
	TSTB	(R1)+
	BEQ	6$
	BR	5$
6$:	CLRB	LPTFLG		;PRINT ON TTY TILL RESELECTED
	BR	99$

50$:	MOV	LPTYPE,R5	;LP20 DRIVER ROUTINE
	MOV	#LPLINI!LPRERR,(R5) ;CLEAR LP20
	DEC	LPPCTR(R5)	;CLEAR PAGE COUNTER
	MOV	#$OUTBF,R0	;GET BUFFER ADDRESS
	MOV	R0,LPBSAD(R5)	;SETUP LP20 BUFFER ADDRESS
	SUB	$OUTPT,R0	;COMPUTE BYTE COUNT
	MOV	R0,LPBCTR(R5)	;SETUP LP20 BYTE COUNT
	MOV	#LPPENB!LPGO,(R5) ;START XFER
	JSR	PC,LP20DN	;WAIT FOR DONE
	BCS	4$		;ERROR
	BR	99$		;DONE

LP20DN:	JSR	PC,C10COP	;PERFORM CLOCK OPERATIONS
	BIT	#LPERR!LPPZRO!LPUCHR!LPDONE,(R5)
	BEQ	LP20DN		;WAIT FOR DONE OR ERROR

	TSTB	(R5)		;DONE ?
	BPL	1$		;NO, ERROR
	CLC
	RTS	PC		;DONE, C-BIT CLEAR RETURN

1$:	SEC
	RTS	PC		;ERROR, C-BIT SET RETURN

$LPTOF:	.ASCIZ	/LPT OFF
/
.EVEN

.ENDC ;.IF DF LPASB
;OPERATOR INTERRUPT TYPEIN CHECKS

$PTTYC:	CLR	R3
	TST	$TTLKF		;INPUT CHECKS INHIBITED ?
	BNE	5$		;YES
	JSR	PC,$TIRDY	;ANY OPERATOR ACTION ?
	BCS	5$		;NO
	MOVB	$TICHR,R3
	BICB	#200,R3
	MOV	R3,$TNCHR
	TENCHR			;SEND CHAR TO TEN
	CMPB	#CNTRLC,R3	;CONTROL C ?
	BNE	3$
	TTPINI			;FLUSH REST OF OUTPUT
	TST	PCMDFLG		;DOING PROGRAM COMMAND ?
	BNE	2$		;YES
	JMP	$TICC		;CONTROL C, RETURN TO CONSOLE

2$:	JMP	PCMDE2		;PROGRAM COMMAND, RETURN TO CALLER

3$:	CMPB	#CNTRLO,R3
	BNE	1$
	COM	CTRLOF		;CONTROL O, STOP OUTPUT
	MOV	#$PTCO,R3
10$:	JSR	PC,C10COP
	JSR	PC,$TORDY
	BCS	10$
	MOVB	(R3)+,$TOCHR
	BNE	90$
	CLR	R3
	BR	5$
90$:	JSR	PC,$TOOUT
	BR	10$
1$:	CMPB	#CNTRLL,R3	;CONTROL L, CHANGE LPT SELECTION
	BNE	4$
	TST	LPTFLG
	BPL	4$
	COMB	LPTFLG		;ONLY IF SELECTED
4$:	CMPB	#CNTRLX,R3	;CONTROL X, CONSOLE COMMAND
	BNE	5$
	JMP	$TICX		;DO "TTILIN" & GO TO "$RPT"
5$:	RTS	PC

$PTCO:	.ASCIZ	/↑O
/
.EVEN
.SBTTL	PRINT CRLF

$PCRLF:	PMSG	<\>
	BR	$$PEX

.SBTTL	RING TTY BELL

$PBELL:	MOVB	#BELL,R0
	PTTY			;DING THE BELL DIRECTLY
	BR	$$PEX

.SBTTL	PRINT SPECIFIED OCTAL DIGITS

$PODT:	MOV	@$EMADR,R1	;TRAILING PARAMETER
	ADD	#2,12(SP)

$PNTODC:MOV	R1,R2		;SETUP DIGIT COUNT
	BGT	1$
	FATAL
1$:	CMP	R1,#6
	BLE	2$
	FATAL
2$:	MOV	#$TTSAV+2,R1
	CLR	(R1)		;SETUP OCTAL NUMBER
	MOV	R0,-(R1)
	JSR	PC,$PODMV	;SETUP PARAMETERS
	CLR	$0FLG		;NO SPACE FOLLOWING NUMBER
	MOVB	$PODCD-1(R2),R3	;GET PRESET SHIFT COUNT
	PROL36			;PRESET NUMBER
	BR	$P23X		;GO PRINT NUMBER

$PODCD:	.BYTE	33.,30.,27.,24.,21.,18.

.SBTTL	PRINT PDP-10 ADDRESS

;PRINTS 23 BIT FORMAT IF ANY OF 13-17 ADDRESS BITS ARE SET.
;OTHERWISE PRINTS 18 BIT FORMAT.

$PADR:	JSR	PC,$$P23
	BIT	#174,4(R1)	;ANY OF 13-17 SET ?
	BNE	$P23Y		;YES
	MOV	#6,R3
	PROL36			;NO, DUMP HI-ORDER BITS
	BR	$P18X		;PRINT 18 BITS

$$P23:	JSR	PC,$P36MV
	MOV	#12.,R3
	PROL36			;POSITION 23 BITS
	BIC	#177600,4(R1)	;CLEAR UPPER JUNK BITS
	RTS	PC
.SBTTL	PRINT LOWER 18 BITS OF 36 BIT NUMBER

$PNT18:	JSR	PC,$P36MV

	MOV	#18.,R3
	PROL36			;SHIFT LOWER 18 BITS TO UPPER
	BR	$P18X

.SBTTL	PRINT LOWER 23 BITS OF 36 BIT NUMBER

$PNT23:	JSR	PC,$$P23

$P23Y:	MOV	#2,R2
	INC	R4
	BR	$P23X

.SBTTL	PRINT 36 BIT NUMBER IN BINARY

$P36B:	JSR	PC,$P36MV
	COM	R5
	BR	$P36BX

.SBTTL	PRINT 36 BIT NUMBER

$PNT36:	JSR	PC,$P36MV
$P36BX:	INC	R4
$P18X=.

2$:	MOV	#6,R2
$P23X=.
1$:	MOV	#3,R3

	PROL36			;ROTATE 3
	JSR	PC,$PRT36	;PRINT OCTAL

	DEC	R2		;FINISHED HALF WORD YET ?
	BNE	1$

	TST	$0FLG
	BEQ	3$
	PSPACE

3$:	DEC	R4		;FINISHED FULL WORD YET ?
	BPL	2$

$$PEX:	EXIT
$PRT36:	MOV	4(R1),R0	;GET THE WORD
	SWAB	R0
	TST	R5
	BNE	1$
	PNTNBR			;PRINT OCTAL
	RTS	PC

1$:	PUSH	R4
	MOV	R0,R4
	MOV	#177776,R3
	SR	R0,2
	BIC	R3,R0
	PNTNBR			;PRINT HI-BIT OF OCTAL
	MOV	R4,R0
	SR	R0,1
	BIC	R3,R0
	PNTNBR			;PRINT MIDDLE-BIT OF OCTAL
	MOV	R4,R0
	BIC	R3,R0
	PNTNBR			;PRINT LO-BIT OF OCTAL
	PSPACE
	POP	R4
	RTS	PC

$P36MV:	MOV	#6,R3		;MOVE 6 BYTES
	MOV	#$TTSAV,R2	;TO SETUP DATA
	MOV	R2,R1
1$:	MOVB	(R0)+,(R2)+
	DEC	R3
	BNE	1$
$PODMV:	CLR	R5
	CLR	R4
	MOV	#4,R3
	MOV	R3,$0FLG	;SET SPACE FLAG
	PROL36			;PRESET NUMBER
	RTS	PC

$PROL36:ROL	(R1)
	ROL	2(R1)
	ROL	4(R1)
	DEC	R3
	BNE	$PROL36
	BR	$$PEX
.SBTTL	PRINT OCTAL

$PNTOCT:MOV	#-1,R4		;PRINT OCTAL
	BR	$PNTO

.SBTTL	PRINT OCTAL ZERO SUPRRESS

$PNTOSC:CLR	R4		;PRINT OCTAL ZERO SUPPRESS
$PNTO:	MOV	#6,R1		;SET FOR 6 DIGITS
	MOV	R0,R2		;SAVE INPUT NUMBERS
	CLR	R5		;CLEAR THE ZERO FILL FLAG
	TST	R4		;ZERO SUPPRESS ?
	BNE	10$		;NO
	TST	R0		;TEST FOR A ZERO INPUT NUMBER
	BNE	1$
	CLR	R1		;INPUT = 0 PRINT AND EXIT
	BR	5$

10$:	INC	R5
1$:	CLR	R0
	ROL	R2		;MSD TO C BIT
	BR	3$

2$:	ROL	R2
	ROL	R2
	ROL	R2
	MOV	R2,R0
3$:	ROL	R0

	BIC	#177770,R0	;GET RID OF JUNK
	BEQ	4$
	INC	R5		;SET ZERO FILL FLAG

4$:	TST	R5		;SUPPRESS ?
	BEQ	6$
5$:	PNTNBR			;PRINT DIGIT
6$:	DEC	R1
	BGT	2$

	TST	R4
	BEQ	7$
	PSPACE			;SPACE UNLESS OCTAL SUPPRESS
7$:	BR	$$PEX1
.SBTTL	CONVERT BINARY TO DECIMAL AND TYPE ROUTINE

$PNTDEC:MOV	#5,R1		;SET FOR 5 DIGIT
	MOV	R0,R2		;SAVE INPUT NUMBER
	CLR	R5		;CLEAR ZERO FILL FLAG
	TST	R0		;TEST SIGN OF INPUT NUMBER
	BPL	1$		;POSITIVE GO TYPE IT
	MOVB	#'-,R0		;PRINT A MINUS SIGN
	PNTCHR			;SEND TO BUFFER
	NEG	R2		;NEGATE THE NUMBER
	MOV	R2,R0		;GET NUMBER AGAIN
	BIC	#100000,R0	;CLEAR SIGN BIT
1$:	TST	R0		;TEST FOR A ZERO INPUT NUMBER
	BNE	2$		;NON ZERO
	PNTNBR			;PRINT A SINGLE ZERO AND EXIT
	BR	9$		;EXIT
2$:	CLR	R3		;ZERO THE CONSTANTS INDEX
3$:	CLR	R0		;CLEAR THE BCD NUMBER
4$:	SUB	$DTBL(R3),R2	;FORM THIS BCD DIGIT
	BLT	5$		;BR IF DONE
	INC	R0		;INCREASE THE BCD DIGIT BY 1
	BR	4$
5$:	ADD	$DTBL(R3),R2	;ADD BACK THE CONSTANT
	TST	R0		;TEST IF DIGIT IS A ZERO
	BEQ	6$		;YES
	INC	R5		;NO SET ZERO FILL FLAG
	BR	7$

6$:	TST	R5		;IS ZERO FILL FLAG SET
	BEQ	8$		;YES EXIT
7$:	BIS	#'0,R0		;MAKE THE BCD DIGIT ASCII
	PNTCHR
8$:	TST	(R3)+		;JUST INCREMENTING
	DEC	R1		;DONE YET
	BGT	3$		;GO DO THE NEXT DIGIT
9$:	PNTCI
	'.			;PRINT DECIMAL POINT
$$PEX1:	EXIT			;RETURN TO USER
.SBTTL	TTY INPUT ROUTINE TTICHR

$TTICHR:CLR	R0
	CMP	$INPTC,$INPTR	;ARE WE AT END ON CURRENT BUFFER
	BGT	$TTIX2		;YES EXIT
	MOVB	@$INPTC,R0	;FETCH CHARACTER FROM BUFFER
	INC	$INPTC

$TTIX1:	BIC	#177600,R0
	BR	$$PSX2		;OK RETURN
$TTIX2:	BR	$$PEX2		;ERROR RETURN

.SBTTL	TTY LOOK

;*TELETYPE KEYBOARD CHECK ROUTINE
;*CHECKS FOR ANY KEY STRUCK,RETURNS IMMEDIATELY
;*RETURNS WITH C-BIT SET IF NO TYPEIN

$TTLOOK:INC	$TTLKF		;SET INHIBIT INPUT CHECKS
	CLR	R0
	JSR	PC,$TIRDY	;ANYTHING BEEN TYPED
	BCS	$TTIX2		;NO, C-BIT RETURN
	MOVB	$TICHR,R0	;YES, PUT IT IN R0
	CLR	$TTLKF		;CLEAR INHIBIT INPUT CHECKS
	BR	$TTIX1		;RETURN

.SBTTL	TTY ALT-MODE CHECK ROUTINE

;*CHECK FOR ALT-MODE IF NOTHING TYPED OR NOT ALTMODE C-BIT SET
;*IF ALT-MODE WAS TYPED THEN C-BIT CLEAR

$TTALTM:TTLOOK			;ANYTHING TYPED
	 BCS	2$		;NO

	CMPB	R0,#175
	BEQ	3$
	CMPB	R0,#176
	BEQ	3$
	CMPB	R0,#ALTMOD
	BEQ	1$

$$PEX2=.
2$:	EXITERR			;EXIT
$$PSX2=.
1$:	EXIT			;OK RETURN

3$:	MOVB	#ALTMOD,R0
	BR	1$
.SBTTL	TTIYES YES OR NO ROUTINE

; NO BITS SET IF YES
; N-BIT SET IF NO
; C-BIT SET IF NEITHER

$TTIYES:TTICHR			;GET INPUT CHARACTER
	 BCS	$$PEX2		;NO CHAR AVAILABLE
	CMPB	#'Y,R0		;WAS THE CHAR A "Y" ?
	BEQ	$$PSX2		;BR IF YES
	CMPB	#'N,R0		;WAS THE CHAR AN "N" ?
	BNE	$$PEX2		;BR IF NO, NEITHER
	BIS	#NBIT,14(SP)	;"NO", SET N-BIT
	BR	$$PSX2

.SBTTL	PRINT A SELECTED NUMBER OF SPACES

$PNTSPC:DEC	R1
	BLT	1$

	PSPACE			;PRINT SPACE
	BR	$PNTSPC

1$:	RTS	PC

.SBTTL	BACKUP TTY INPUT BUFFER POINTER

$TTBACK:CMP	$INPTC,#$INBUF
	BLE	$$PEX2		;CAN'T, C-BIT SET RETURN
	DEC	$INPTC		;BACKUP POINTER
	BR	$$PSX2
.SBTTL	READ SWITCH REGISTER

$SWITCH:MOV	SWR,R0		;PUT SWR INTO R0

1$:	MOV	R0,$SWTCH	;SAVE A COPY FOR FUTURE REFERENCE
	BR	$$PEX3		;RETURN TO USER

.SBTTL	RETURN WITH COPY OF SWITCHES 

$SWTSAM:MOV	$SWTCH,R0	;COPY OF SWITCHES TO RO
	BR	$$PEX3

.SBTTL	SET FORCE PRINT FLAG

$PFORCE:SETFLG
	  $FORCE		;177777 TO FORCE FLAG
	BR	$$PEX3		;RETURN


.SBTTL	CLEAR FORCE PRINT FLAG

$PNORML:CLR	$FORCE		;0 TO FORCE FLAG
$$PEX3:	EXIT			;RETURN

;TTILIN ENTRY POINT FROM RUNLP

$TILRN:	CLR	TILNWF		;CLEAR TTY WAIT FLAG
	JSR	PC,$TILN3	;INIT TTILIN ROUTINE
	PUSH	$FORCE
	MOV	#$INBUF,R1
	BR	$TILN2		;GO INPUT, 1ST CHAR ALREADY AVAILABLE

$TILN3:	CLR	CTRLOF		;CLEAR CONTROL O FLAG
	CMP	#$OUTBF,$OUTPT	;ANY OUTPUT WAITING ?
	BEQ	1$		;NO
	PRINTT			;YES, PRINT IT
1$:	CLR	$TPLIT		;CLEAR LINES ON PAGE
	CLR	$0FLG		;CLEAR RUBOUT FLAG
	CLR	$TTYTIM		;CLEAR TTY TIMEOUT
	RTS	PC
.SBTTL	INPUT A STRING FROM TTY

$TTILNW:SETFLG			;SET TTY WAIT FLAG
	  TILNWF
	BR	$TILNX

$TTILIN:CLR	TILNWF		;CLEAR TTY WAIT FLAG

$TILNX:	JSR	PC,$TILN3	;INIT ROUTINE
	PUSH	$FORCE
	PFORCE
95$:	MOV	#$INBUF,R1
$TILN1=.
2$:	JSR	PC,C10COP	;PERFORM CLOCK OPERATIONS
	TST	TILNWF		;WAIT FOREVER ?
	BNE	21$		;YES, NO TIMEOUT
	CMP	$TTYTIM,#<3*60.*60.>;TTY TIMED OUT ?
	BGT	99$		;YES, C-BIT SET EXIT

21$:	JSR	PC,$TIRDY	;TTY IN FLAG SET
	BCS	2$
$TILN2=.
	CLR	$TTYTIM
	MOVB	$TICHR,(R1)	;MOVE CHARACTER TO BUFFER
	BICB	#200,(R1)
	MOVB	(R1),$TNCHR	;SAVE CHAR FOR TEN
	BEQ	2$		;NULL, IGNORE
	TENCHR			;SEND TEN THE CHAR

	CLR	R5		;DO SPECIAL CHAR PROCESS
80$:	CMPB	(R1),TILINC(R5)
	BEQ	81$		;FOUND
	INC	R5
	TSTB	TILINC(R5)
	BEQ	82$		;IF 0, END OF LIST
	BR	80$

81$:	SL	R5,1		;DISPATCH
	JMP	@TILINA(R5)
82$:	CMPB	(R1),#141
	BLT	83$
	CMPB	(R1),#172
	BGT	83$
	BICB	#40,(R1)	;CONVERT LOWER TO UPPER CASE

83$:	PUSH	R1
	MOVB	(R1),R1		;PUT CHAR IN R1
	PLDBUF			;INSERT FOR LPT
	INC	$OUTPP		;MOVE PRINTED-TO-POSITION
	POP	R1

10$:	TST	$0FLG		;RUBOUT KEY SET?
	BEQ	11$		;BR IF NO

	MOVB	#BKSLH,R0	;TYPE A BACK SLASH
	PTTY
	CLR	$0FLG		;CLEAR RUBOUT FLAG

11$:	MOVB	(R1)+,R0	;CHAR TO R0
	PTTY			;PRINT IT
	BR	2$		;BACK FOR MORE

99$:	MOV	R1,$INPTR	;SAVE INPUT POINTER
	POP	$FORCE
	EXITERR			;TIMED OUT, C-BIT SET RETURN

$TIRUB:	TST	$0FLG		;MULTIPLE RUBOUTS ?
	BNE	1$		;YES
	INC	$0FLG		;SET RUBOUT FLAG
	MOVB	#BKSLH,R0	;TYPE A BACKSLASH
	PTTY

1$:	DEC	R1		;BACKUP BY ONE
	CMP	R1,#$INBUF-1	;INPUT BUFFER EMPTY ?
	BNE	2$		;NO

	PCRLF			;EMPTY, PRINT CR/LF
	POP	$FORCE
	BR	$TILNX		;AWAIT NEW LINE

2$:	MOVB	(R1),R0		;PRINT RUBBED OUT CHAR
	PTTY
	BR	$TILN1
;SPECIAL CHAR PROCESS

$TICU:	PMSG	<↑U\>		;CONTROL U, DUMP LINE
	POP	$FORCE
	BR	$TILNX

$TICR:	INC	R1		;CARRIAGE RETURN
	MOVB	#LF,(R1)	;INSERT LF ALSO

$TIBELL:PCRLF			;PRINT CR/LF

$TIEXT:	MOV	R1,$INPTR	;UPDATE INPUT POINTER
	MOV	#$INBUF,$INPTC	;INIT CHAR POINTER
	POP	$FORCE
	EXIT			;RETURN

$TIALT:	MOVB	#ALTMOD,(R1)	;ALTMODE
	PMSG	<$\>		;PRINT DOLLAR SIGN CR/LF
	BR	$TIEXT

$TIBKS:	PCRLF			;BACKSLASH, DO LOCAL CR/LF
	BR	$TILN1


$TICC:	PNTCI			;CONTROL C, ABORT
	"↑C
	JMP	$CNTLC

$TICL:	TST	LPTFLG		;CONTROL L, LPT SELECTION
	BPL	$TILN1
	COMB	LPTFLG
	BR	$TILN1

$TILF:	MOVB	(R1),R0		;LINE FEED
	PTTY
	BR	$TIEXT

$TICO:	CLR	CTRLOF		;CLEAR CONTROL O FLAG
	PNTCI
	"↑O
	BR	$TIBELL		;CR/LF & TERMINATE

$TICX:	TTPINI
	PNTCI
	"↑X
	TTILIN			;GET COMMAND LINE
	 BCS	$TICC		;TIMED OUT
	MOV	$KONSP,SP	;RESTORE STACK POINTER
	JMP	$RPT		;GO PROCESS COMMAND
;SPECIAL CHARACTERS

TILINC:	.BYTE	CR,LF
	.BYTE	BELL,ALTMOD
	.BYTE	175,176
	.BYTE	CNTRLL,CNTRLU
	.BYTE	CNTRLC,BKSLH
	.BYTE	RUBOUT,CNTRLO
	.BYTE	XON,XOFF
	.BYTE	CNTRLX,0

;SPECIAL CHAR DISPATCH TABLE

TILINA:	$TICR
	$TILF
	$TIBELL
	$TIALT
	$TIALT
	$TIALT
	$TICL
	$TICU
	$TICC
	$TIBKS
	$TIRUB
	$TICO
	$TIBELL
	$TIBELL
	$TICX
.SBTTL	CTY & FSTTY DL11 DRIVERS

$TIRDY:	TSTB	@$TKS		;ANY CTY INPUT ?
	BPL	2$		;NO
	BIT	#20000,@$TKB	;YES. BREAK?
	BNE	5$		;BRANCH IF YES
	MOVB	@$TKB,$TICHR	;GET CHAR
1$:	BICB	#200,$TICHR	;CLEAR PARITY BIT
	CLC			;C-BIT CLEAR RETURN
	RTS	PC

5$:	MOVB	#MSWCHR,$TICHR	;BREAK SEEN. 
	BR	1$

2$:
.IF NDF TELASB
	TST	DL11EFLG	;DOING DL11E ?
	BEQ	3$		;NO
	BIT	#DLCTS,@$FSTKS	;YES, STILL HAVE CLEAR TO SEND ?
	BEQ	4$		;NO
.IFF
	TST FSFLG		;DOING DL11E?
	BEQ 3$			;NO
	BIT #DLCTS,@$FSTKS	;STILL HAVE CLEAR TO SEND?
	BEQ 3$			;NO
.ENDC
	TSTB	@$FSTKS		;ANY FSTTY INPUT ?
	BPL	3$		;NO
	MOVB	@$FSTKB,$TICHR	;YES, GET CHAR
	BR	1$		;C-BIT CLEAR RETURN

3$:	SEC			;NO INPUT, C-BIT SET RETURN
	RTS	PC

.LIF NDF TELASB
4$:	JMP	FSDISC		;DL11E DISCONNECT

$TORDY:	TSTB	@$TPS		;IS CTY READY ?
	BPL	2$		;NO
.IF NDF TELASB
	TST	DL11EFLG	;DOING DL11E ?
	BEQ	1$		;NO
	BIT	#DLCTS,@$FSTKS	;STILL HAVE CLEAR TO SEND ?
	BEQ	3$		;NO
.IFF
	TST FSFLG
	BEQ 1$
	BIT #DLCTS,@$FSTKS	;STILL HAVE CLEAR TO SEND?
	BEQ 1$			;NO
.ENDC
	TSTB	@$FSTPS		;IS FSTTY READY ?
	BPL	2$		;NO

1$:	CLC			;ALL READY, C-BIT CLEAR RETURN
	RTS	PC

2$:	SEC			;NOT READY
	RTS	PC

.LIF NDF TELASB
3$:	JMP	FSDISC		;DL11E DISCONNECT

$TOOUT:	MOVB	$TOCHR,@$TPB	;PRINT ON CTY

.IF NDF TELASB
	TST	DL11EFLG
	BEQ	1$
.IFF
	TST FSFLG
	BEQ 1$
	BIT #DLCTS,@$FSTKS	;STILL HAVE CLEAR TO SEND
	BEQ 1$
.ENDC
	MOVB	$TOCHR,@$FSTPB	;PRINT ON FSTTY
1$:	RTS	PC
.SBTTL	READ AN OCTAL NUMBER FROM THE TTY

;REGISTER USAGE
;R0 = TTY CHARACTER 7 BIT FROM $INBUF
;R2 = WORK REGISTER
;R3 = CLEARED/SET = NO OCTAL CHARS/AT LEAST 1 OCTAL CHAR

$TTIOCT:CLR	R2		;CLEAR WORK REGISTER
	JSR	PC,$TMINUS	;CHECK FOR PLUS & MINUS
1$:	TTICHR			;PICKUP THIS CHARACTER
	 BCS	2$

	CMPB	R0,#60		;MAKE SURE THIS CHARACTER
	BLT	2$		;IS AN OCTAL DIGIT
	CMPB	R0,#67
	BGT	2$

	INC	R3		;TO SHOW I GOT ONE CHARACTER

	ASL	R2
	ASL	R2
	ASL	R2

	BIC	#177770,R0
	ADD	R0,R2
	BR	1$

2$:	CLR	R0		;SET UP FOR EXIT

	TST	R3		;DID WE GET ANY DATA
	BEQ	$$PEX7		;NO, ERROR RETURN

	MOV	R2,R0
	TST	R4		;NEGATE FLAG SET ?
	BEQ	$$PEX6		;NO
	NEG	R0		;YES, MAKE NUMBER NEGATIVE
$$PEX6:	JMP	$TTERM		;VERIFY TERMINATION & EXIT
$$PEX7:	EXITERR			;ERROR RETURN

$TMINUS:CLR	R3		;CLEAR CHAR COUNTER
	CLR	R4		;CLEAR NEGATE FLAG
	MOV	$INPTC,R5	;SAVE INPUT POINTER
	TTICHR			;GET 1ST CHAR
	 BCS	82$		;NONE AVAILABLE
	CMPB	#'+,R0
	BEQ	80$
	CMPB	#'-,R0		;NEGATE ?
	BNE	81$		;BR IF NO
	INC	R4		;YES, SET NEGATE FLAG
80$:	INC	R5		;YES, ADVANCE PAST -
81$:	MOV	R5,$INPTC
82$:	RTS	PC
.SBTTL	READ A DECIMAL NUMBER FROM THE TTY

$TTIDEC:MOV	#$TTSAV,R2	;RESERVE STORAGE
	JSR	PC,$TMINUS	;CHECK FOR PLUS & MINUS
1$:	TTICHR			;READ IN A CHARACTER
	 BCS	2$
	CMPB	R0,#60		;MAKE SURE THIS CHARACTER
	BLT	2$		;IS A DIGIT BETWEEN 0 & 9
	CMPB	R0,#71
	BGT	2$
	INC	R3		;SO I KNOW I GOT A DIGIT
	BIC	#177760,R0	;DON'T LET NUMBER GET TO BIG
	MOVB	R0,(R2)+
	BR	1$
2$:	CLR	R0		;CLEAR OUTPUT
	TST	R3		;DID WE GET ANY THING
	BEQ	6$		;NO

;NOW WE CONVERT IT

	CLR	R1		;CLEAR TABLE INDEX
3$:	CMP	R2,#$TTSAV
	BLT	5$		;YES NORMAL EXIT
	MOVB	-(R2),R5	;PUT IN R5
4$:	DEC	R5		;DONE YET
	BLT	7$
	ADD	$TBLL(R1),R0	;TALLY IT UP
	BR	4$
7$:	TST	(R1)+		;UPDATE TABLE TALLY
	BR	3$
5$:	TST	R4		;NEGATE NUMBER ?
	BEQ	9$
	NEG	R0		;YES
9$:	BR	$$PEX6		;RETURN
6$:	BR	$$PEX7		;ERROR RETURN
.SBTTL	READ A 12 DIGIT OCTAL (36 BIT) NUMBER

;$0FLG, 0=NO DATA; 0,-1=ONE DATA WORD; -1,-1= TWO PART DATA
;DATA IS TRUNCATED TO 6 OCTALS IN EITHER HALF OF 2 PART DATA
;DATA IS TRUNCATED TO 12 OCTALS IN 1 PART DATA
;DURING CONVERSION
;1 PART DATA; $0FLG =0
;2 PART DATA; $0FLG=-1,0 DURING HI6; 0,-1 DURING LO6

$TTI36:	JSR	PC,$TI36C
	CLR	$SVH
	CLR	$SVM
	CLR	$0FLG
	CLR	$NEG
	JSR	PC,$TMINUS
	TST	R4
	BEQ	1$
	INCB	$NEG+1		;SET NEGATE FLAG

1$:	TTICHR			;READ A CHAR
99$:	 BCS	98$		;BUFFER EMPTY

	CMPB	R0,#60		;MAKE SURE ITS OCTAL
	BLT	2$
	CMPB	R0,#67
	BGT	2$

	MOVB	#-1,$0FLG	;WE GOT AT LEAST 1 DIGIT
	BR	1$

2$:	TSTB	$0FLG
	BEQ	69$
	CMPB	R0,#BLANK	;WAS IT A SPACE ?
	BNE	3$		;NOPE
	MOVB	#-1,$0FLG+1	;SET 2 WORD FLAG
	TTICHR			;GET 1ST CHAR OF 2ND PART
98$:	 BCS	97$
	CMPB	#'+,R0
	BEQ	71$
	CMPB	#'-,R0		;IS IT MINUS ?
	BEQ	21$		;YES
	DEC	$INPTC		;NO, BACKUP INPUT POINTER
	BR	1$
21$:	INCB	$NEG		;SET 2ND PART NEGATE FLAG
71$:	BR	1$		;PROCESS 2ND HALF WORD
3$:	MOV	R5,$INPTC	;RESET INPUT POINTER
	CLRB	$0FLG

4$:	TTICHR
97$:	 BCS	96$
	CMPB	R0,#60
	BLT	5$
	CMPB	R0,#67
	BGT	5$

	BICB	#370,R0
	MOV	#3,R1

6$:	JSR	PC,SHFT36	;SHIFT 36 BIT WORD LEFT 3

	BISB	R0,$DRAM	;INSERT NEW CHAR
	BR	4$

5$:	TSTB	$0FLG+1		;DOING 2 PART NUMBER ?
	BEQ	8$		;BR IF NO

51$:	TSTB	$NEG+1		;NEGATE UPPER PART ?
	BEQ	52$		;NO

	JSR	PC,NEG36	;NEGATE 36 BIT WORD

52$:	MOV	#18.,R1		;YES, MOVE NUMBER TO UPPER 18 BITS

7$:	JSR	PC,SHFT36	;SHIFT 36 BIT WORD LEFT 18

	MOV	-(R5),$SVH	;SAVE UPPER BITS
	MOV	-(R5),$SVM	;SAVE MIDDLE BITS
	JSR	PC,$TI36C

	SWAB	$0FLG		;MAKE $0FLG 0,-1
	TTICHR			;GET 1ST CHAR OF 2ND PART
96$:	 BCS	9$
	CMPB	#'+,R0
	BEQ	4$
	CMPB	#'-,R0		;IS IT MINUS ?
	BEQ	4$		;YES
	DEC	$INPTC		;NO, BACKUP INPUT POINTER
	BR	4$
8$:	TSTB	$0FLG
	BEQ	10$		;BR IF 1 PART
	TSTB	$NEG		;NEGATE LOWER PART ?
	BEQ	81$		;NO

	JSR	PC,NEG36	;NEGATE 36 BIT WORD

81$:	MOV	#$DRAM+2,R1
	BIC	#177774,(R1)
	BIS	$SVM,(R1)+
	CLR	(R1)		;CLEAR BITS 0-17
	BIS	$SVH,(R1)	;REINSERT UPPER BITS
	BR	12$

10$:	TSTB	$NEG+1		;MAKE NUMBER NEGATIVE ?
	BEQ	12$		;BR IF NO
	JSR	PC,NEG36	;NEGATE 36 BIT WORD

12$:	BIC	#177760,$DRAM+4	;STRIP OVERFLOW
	MOV	#$DRAM,R0	;RETURN STORAGE ADR IN R0
	JMP	$TTERM		;VERIFY TERMINATION & EXIT
69$:	CLR	R0		;NO DIGITS TYPED
9$:	TTERM			;VERIFY TERMINATION
	EXITERR			;ERROR RETURN

;SHIFT 36 BIT WORD C(R1) PLACES LEFT

SHFT36:	MOV	#$DRAM,R5
	CLC
	ROL	(R5)+
	ROL	(R5)+
	ROL	(R5)+
	DEC	R1
	BGT	SHFT36
	RTS	PC

;NEGATE - TWO'S COMPLEMENT 36 BIT WORD

NEG36:	MOV	#$DRAM,R1	;MAKE 1'S COMPLEMENT
	COM	(R1)+
	COM	(R1)+
	COM	(R1)
	MOV	#$DRAM,R1
	ADD	#1,(R1)+	;MAKE THAT 2'S COMPLEMENT
	ADC	(R1)+
	ADC	(R1)
	BIC	#177760,(R1)	;STRIP OVERFLOW
	RTS	PC

$TI36C:	MOV	#$DRAM,R0	;CLEAR STORAGE
	CLR	(R0)+
	CLR	(R0)+
	CLR	(R0)+
	RTS	PC
.SBTTL	SIGNED MULTIPLY SUBROUTINE

$MULTP:	PUSH	R0
	MOV	22(SP),R1
	MOV	20(SP),R0	;MULTIPLICAND
	CLR	R4		;CLEAR SIGN
	TST	R0		;TEST SIGN
	BPL	1$

	INC	R4		;SET SIGN BIT
	NEG	R0		;MAKE MULTIPLICAND POSITIVE

1$:	TST	R1		;TEST SIGN OF MULTIPLIER
	BPL	2$

	DEC	R4		;UPDATE SIGN BIT
	NEG	R1		;MAKE MULTIPLIER POSITIVE

2$:	MOV	#17.,R3		;SET LOOP COUNT
	CLR	R2		;SET UP FOR MULTIPLY LOOP

3$:	 BCC	4$		;DONT ADD IF MULTIPLICAND IS ZERO
	ADD	R1,R2

4$:	ROR	R2		;POSITION THE PARTIAL PRODUCT
	ROR	R0		;AND THE MULTIPLICAND
	DEC	R3		;DONE YET
	BNE	3$		;NOPE

	TST	R4		;TEST SIGN
	BEQ	5$		;PRODUCT IS POSITIVE

	NEG	R0		;PRODUCT SHOULD BE NEGATIVE
	NEG	R2
	SBC	R0		;SUBTRACT CARRY

5$:	MOV	R0,20(SP)	;MOST SIGNIFICANT BITS
	MOV	R2,22(SP)	;LEAST SIGNIFICANT BITS
	POP	R0
	EXIT			;EXIT
.SBTTL	BREAK CHARACTER

$TTIBRK:DEC	$INPTC		;BACKUP INPUT POINTER
	TTICHR
	 BCC	$$PEX4		;NOTHING IN BUFFER
$$PEX5:	EXITERR

.SBTTL	TELETYPE INPUT SPACE DELETE ROUTINE

$TTSDL:	TTICHR
	 BCS	$TTSDX		;BUFFER EMPTY
	CMPB	R0,#BLANK
	BEQ	$TTSDL		;DELETE SPACES
	CMPB	R0,#TAB
	BEQ	$TTSDL		;DELETE TABS
	CMPB	#'-,R0			;TREAT + OR -
	BEQ	3$			;SAME AS NUMBER
	CMPB	#'+,R0
	BEQ	3$
	CMPB	R0,#60
	BLT	1$		;BR IF NON-NUMBER
	CMPB	R0,#71
	BGT	1$		;BR IF NON-NUMBER
3$:	DEC	$INPTC		;NUMBER, BACKUP INPUT POINTER
	BR	$$PEX4		;C-BIT CLEAR RETURN
1$:	CMPB	R0,#':		;COLON OR SLASH, V-BIT & C-BIT SET
	BEQ	10$
	CMPB	R0,#'/
	BEQ	10$
	CMPB	R0,#'↑		;UPARROW, Z-BIT & C-BIT SET
	BNE	$$PEX5
	BIS	#ZBIT,14(SP)
	BR	$$PEX5

10$:	BIS	#VBIT,14(SP)
	BR	$$PEX5
$TTSDX:	JMP	$PARAM
.SBTTL	TELETYPE INPUT TERMINATION CHECK

$TTITRM:INC	$INPTC		;BECAUSE "TTERM" DECREMENTS
$TTBTRM:TTERM			;VERIFY TERMINATOR
	BCS	$TTSDX		;BAD, C-BIT SET RETURN
	BR	$$PEX4		;OK

$TTERM:	PUSH	R0
	DEC	$INPTC		;BACKUP INPUT POINTER
	TTICHR			;GET TERMINATION CHAR
	 BCS	2$		;NONE
	MOV	#TRMTAB,R1	;SETUP TERMINATION SCAN POINTER
1$:	CMPB	R0,(R1)		;CHAR MATCH LEGAL TERMINATOR ?
	BEQ	2$		;YES
	TSTB	(R1)+		;NOT YET, GO TO NEXT
	BEQ	3$		;NO MATCH, ERROR
	BR	1$
2$:	POP	R0
	BR	$$PEX4		;OK, C-BIT CLEAR RETURN
3$:	POP	R0
	BR	$$PEX5		;ERROR, C-BIT SET RETURN

TRMTAB:	.BYTE	SPACE,TAB
	.BYTE	COMMA,CR
	.BYTE	ALTMOD,72	;COLON
	.BYTE	57,0		;SLASH
.SBTTL	INPUT & CHECK OCTAL NUMBER

$TTCOCT:TTISDL
	 BCS	$TTSDX
	TTIOCT
	 BCS	$TTSDX		;NON-OCTAL
	BR	$$PEX4		;OK

$TOCTE:	TTCOCT
	BIT	#1,R0		;ONLY EVEN OCTAL
	BNE	$TTSDX
	BR	$$PEX4

.SBTTL	TELETYPE DELETE SPACES & INPUT OCTAL NUMBER

$TTSDO:	TTCOCT
	TST	R0		;MUST BE POSITIVE ALSO
	BMI	$TTSDX
$$PEX4=.
	EXIT

.SBTTL	TELETYPE DELETE SPACES & INPUT 36BIT NUMBER

$TTS36:	TTISDL			;DELETE SPACES
	 BCS	$TTSDX
	TTI36			;INPUT 36 BIT NUMBER
	 BCS	$TTSDX
	BR	$$PEX4

.SBTTL	TELETYPE INPUT C-RAM ADDRESS

$TICRA:	TTISDO			;GET ADDRESS
	CMP	R0,#2777
	BLE	$$PEX4
	JMP	ADRERR		;TOO BIG
.SBTTL	SHIFT R0 RIGHT/LEFT ROUTINES

$SHFTR:	MOV	@$EMADR,R1	;GET SHIFT COUNT
1$:	ASR	R0		;SHIFT RIGHT
	DEC	R1
	BGT	1$
$SHFTX:	EXITSKP			;SKIP OVER TRAILING PARAMETER

$SHFTL:	MOV	@$EMADR,R1
1$:	ASL	R0		;SHIFT LEFT
	DEC	R1
	BGT	1$
	BR	$SHFTX

.SBTTL	PRINT MESSAGE, CONDITIONAL DEPENDING ON "RPTFLG"

$$PMSR:	TSTB	RPTFLG		;DOES REPEAT FLAG ALLOW PRINTING ?
	BNE	$SHFTX		;NO

.SBTTL	PRINT MESSAGE

$$PMSG:	MOV	@$EMADR,R0	;MESSAGE ADDRESS TO R0
	PNTAL			;PRINT
	BR	$SHFTX		;SKIP RETURN

.SBTTL	PRINT CHARACTER IMMEDIATE

$PNTCI:	MOV	$EMADR,R2	;GET DATA ADDRESS
	MOVB	(R2)+,R1	;GET FIRST BYTE
	PLDBUF			;INSERT IN BUFFER
	MOVB	(R2),R1		;GET 2ND BYTE
	BEQ	1$		;IS THERE ANY ?
	PLDBUF			;YES, INSERT IN BUFFER
1$:	BR	$SHFTX		;SKIP RETURN
.SBTTL	SMALL TIME DELAY

$DELAY:	MOV	#10.,R1
1$:	DEC	R1
	BNE	1$
	EXIT

;CONSOLE TIME DELAY FOR REPEAT LOOPS

.TD:	TTISDL
	 BCS	1$		;NO ARG, DO ONCE
	TTIDEC
	 BCS	1$		;DO ONCE ANYWAY
	MOV	R0,R1		;SAVE DELAY COUNT
	BR	2$
1$:	CLR	R1
2$:	TDELAY			;SMALL TIME DELAY
	DEC	R1		;DONE REQUESTED DELAYS ?
	BGT	2$
	JMP	$KONSL

.SBTTL	SAVE AND RESTORE R0-R5 ROUTINES

$REGSAV:PUSH	R0
	PUSH	16(SP)
	PUSH	16(SP)
	RTI

;*RESTORE R0-R5

$REGRST:MOV	14(SP),34(SP)
	MOV	12(SP),32(SP)
	ADD	#16,SP
	POP	<R0,R5,R4,R3,R2,R1>
	RTI
;FATAL VECTOR INTERRUPT

$FATLE:	PUSH	R0
	PMSG	<?FATAL INTR>
	BR	$EOR

$TIMOT:	PUSH	R0
	PMSG	<?BUS TIMEOUT>
	BR	$EOR

$RESVD:	PUSH	R0
	PMSG	<?RESERVED INST>

$EOR:	CLR	TENRUN
	POP	R0
	PUSH	<R1,R2,R3,R4,R5,R0>
	BR	$EOR2

;STACK UNDERFLOW

$STUF:	MOV	#STACK-2,SP
	MOV	SP,$KONSP
	PMSG	<?ST UNFLO>
	CLR	PCMDFLG
	JMP	$CNTLC

$NOTAS:	PMSG	<?UNAS EMT>
$EOR2:	CLR	PCMDFLG
	JMP	$PH1

$FATAL:	PUSH	R0
	PMSG	<?FATAL>
	BR	$EOR2
.SBTTL	EMT DECODER

;*THIS ROUTINE WILL PICKUP THE LOWER BYTE OF THE "EMT" INSTRUCTION
;*AND USE IT TO INDEX THROUGH THE EMT TABLE FOR THE STARTING ADDRESS
;*OF THE DESIRED ROUTINE. THEN USING THE ADDRESS OBTAINED IT WILL
;*GO TO THAT ROUTINE.

$EMTRP:	CMP	SP,#$$STKM		;check against stack bottom
	BLE	$STUF			;OFF BOTTOM OF STACK
	PUSH	<R1,R2,R3,R4,R5,R0>
	MOV	14(SP),R0		;GET EMT ADDRESS (+2)
	BIC	#17,16(SP)		;CLEAR ALL STATUS BITS
	MOV	R0,$EMADR		;SAVE
	MOV	-(R0),R0		;GET RIGHT BYTE OF EMT
	BIC	#177400,R0
	CMP	R0,#<<$EMTAE-$EMTAD>/2>
	BGE	$NOTAS			;EMT IN RANGE ?
	SL	R0,1			;ROUND TO WORD ADDRESS
	MOV	$EMTAD(R0),R0		;INDEX TO TABLE
	RTS	R0			;GO TO ROUTINE

.SBTTL	EMT TABLE

;*THIS TABLE CONTAINS THE STARTING ADDRESSES OF THE ROUTINES CALLED
;*BY THE "EMT" INSTRUCTION.

;	ROUTINE
;	-------
$EMTAD:	$FATAL		;EMT + 0
	$ERRHLT		; 1
	$PRGHLT		; 2
	$RUNLP		; 3
	$TTILIN		; 4	
	$TTICHR		; 5
	$TTLOOK		; 6
	$TTIOCT		; 7
	$TTCOCT		;EMT + 10
	$TTIDEC		; 11	
	$TTIYES		; 12
	$TTALTM		; 13
	$TTI36		; 14	
	$TTIBRK		; 15
	$TTSDL		; 16
	$TTSDO		; 17
	$TTS36		;EMT + 20
	$TICRA		; 21
	$TTITRM		; 22
	$TTBTRM		; 23
	$PNTAL		; 24	
	$$PMSG		; 25
	$$PMSR		; 26
	$PNTCHR		; 27
	$PNTNBR		;EMT + 30
	$PCRLF		; 31
	$PSPACE		; 32
	$PSLASH		; 33
	$PCOMMA		; 34
	$PNTOCT		; 35
	$PNTOSC		; 36	
	$PNTDEC		; 37
	$PNT18		;EMT + 40
	$PNT23		; 41
	$PNT36		; 42
	$PFORCE		; 43
	$PNORML		; 44	
	$PBELL		; 45
	$PNTODC		; 46
	$PODT		; 47
	$REGSAV		;EMT + 50	
	$REGRST		; 51
	$CMP36		; 52	
	$SHFTR		; 53
	$SHFTL		; 54
	$SETFLG		; 55
	$DELAY		; 56
	$SWITCH		; 57	
	$SWTSAM		;EMT + 60
	$EOP		; 61	
	$ERREOP		; 62
	$EOPSET		; 63
.IF DF MONASB
	$COMLIN		; 64
	$COMSND		; 65
	$COMACK		; 66
	$COMNAK		; 67
	$COMCLR		;EMT + 70
	$COMCTL		; 71
.IFF
.REPT 6
	$FATAL		;64-71
.ENDR
.ENDC
	$MULTP		; 72	
	$WCRAM		; 73
	$RCRAM		; 74
	$WWADR		; 75
	$MRESET		; 76	
	$TENSP		; 77
	$SM		;EMT + 100
	$XCT		; 101
	$LODAR		; 102
	$EXAM		; 103
	$EXAMT		; 104
	$DPOS		; 105
	$DPOST		; 106
	$DPOSVR		; 107
	$DPSVT		;EMT + 110
	$D10MON		; 111
	$D10ZRO		; 112
	$DTEBAS		; 113
	$DFXCT		; 114
	$DXCTT		; 115
	$DFRD		; 116
	$DFRDMV		; 117	
	$DFWRT		;EMT + 120
	$DFWIR		; 121
	$DFSCLK		; 122
	$DFPC		; 123
	$DFVMA		; 124
	$DFADB		; 125
	$RDRAM		; 126
	$WDRAM		; 127
	$DRAMAD		;EMT + 130
	$BURST		; 131
	$PNTCPU		; 132
	$PRGCMD		; 133	
	$P36B		; 134
	$ECLOK		; 135
	$ESYNC		; 136
	$PADR		; 137
	$DFRDT		;EMT + 140
	$DWRTT		; 141
	$PCRAM		; 142
	$PDRAM		; 143
	$TTBACK		; 144
	$TENSW		; 145
	$PROL36		; 146
	$SETMPH		; 147
	$DFVMH		;EMT + 150
	$PRINTT		; 151
	$PTTY		; 152

.IF DF LPTASB
	$PLPT		; 153
.IFF
	$FATAL
.ENDC

	$PLDBUF		; 154
	$R50UPK		; 155
	$DTINIT		; 156

.IF DF RPASB
	$RPINIT		; 157
.IFF
	$FATAL
.ENDC

	$DVDATA		;EMT + 160
	$DTREAD		; 161

.IF DF RPASB
	$RPREAD		; 162
.IFF
	$FATAL
.ENDC

	$DVFRAM		; 163
	$DVWRD		; 164
	$ASCR50		; 165

.IF DF RPASB
	$RPLOAD		; 166
	$RPFIND		; 167
	$RPLKUP		;EMT + 170
	$RPRDFL		; 171
	$RPWRFL		; 172
	$RPWRIT		; 173
	$RPADDR		; 174
	$RPBASE		; 175
.IFF
.REPT 8
	$FATAL
.ENDR
.ENDC

	$TENCHR		; 176
	$PNTBAK		; 177
	$TOCTE		;EMT + 200
	$TTERM		; 201
	$CLKPRM		; 202
	$MICNUL		; 203
	$MICFIL		; 204
	$DTWRT		; 205
	$NAMEXT		; 206
	$DTAFILE	; 207

.IF DF RPASB
	$RPFILE		;EMT + 210
.IFF
	$FATAL
.ENDC

	$DTRDFL		; 211
	$DTWTFL		; 212
	$DTBASE		; 213
	$PNTCI		; 214
	$PNTRST		; 215
	$PRGNPT		; 216
	$TTPINI		; 217
.IF DF MONASB
	$COMCMD		;EMT + 220
	$CMRTRY		; 221
	$COMENQ		; 222
	$COMEOT		; 223
.IFF
.REPT 4
	$FATAL
.ENDR
.ENDC
	$TTILNW		; 224
	$TTICCL		; 225
	$DFLEGAL	; 226
	$PTAB		; 227

.IF DF RXASB
	$RXFILE		;EMT + 230
	$RXINIT		; 231
	$RXRDFL		; 232
	$RXWTFL		; 233
	$RXBASE		; 234
	$RXREAD		; 235
	$RXWRT		; 236
.IFF
.REPT 7
	$FATAL
.ENDR
.ENDC

.IF DF RPASB
	$RPERR		; 237
.IFF
	$FATAL
.ENDC

$EMTAE=.

$ESYNC:	PUSH	R0
	JMP	$NOTAS
.SBTTL	POWER DOWN AND UP ROUTINES

$PWRDN:	MOV	#$PWRUP,@#PWRVEC	;SET UP VECTOR
$ILLUP:	HALT
	BR	$ILLUP			;HANG UP

;POWER UP ROUTINE

$PWRUP:	MOV	#CPUPR,PS		;SET CPU PRIORITY
	MOV	#STACK,SP		;SET SP 
.LIF DF SAILVR
	JSR PC,CLKSTA			;START CLOCK
	CLR	R5			;WAIT LOOP FOR THE TTY
1$:	INC	R5			;WAIT FOR THE INC
	BNE	1$			;OF  WORD
	MOV	#$PWRDN,@#PWRVEC	;SET UP THE POWER DOWN VECTOR
	CLR	CONSOL-2
	CLR	LPTFLG			;DISCONNECT LINE PRINTER
.IF NDF TELASB
	CLR	DL11EFLG		;DISCONNECT KLINIK !!!
.IFF
	CLR FSFLG
	MOV #DLRTS,@$FSTKS
	MOV #40000.,R0			;40000*2.36USEC = 94.4 MS
	SOB R0,.			;WAIT FOR DATA SET TO HANG UP
	BIS #DLRTS!DLDTR!DLDIE,@$FSTKS	;SET DATA TERM READY AND DATA SET INT ENB
		;LEAVE REQUEST TO SEND UP ALTHOUGH WE DON'T USE IT
.ENDC
	INC	$PWRCNT			;COUNT POWER RESTARTS

.IF NDF SAILVR
	MOV	#KWLKS,R3
	CLR	R5
10$:	TSTB	(R3)		;WAIT FOR CLOCK TICK
	BPL	10$
	BIC	#200,(R3)
.IFF
	CLR	CLKFLG
10$:	TST	CLKFLG
	BEQ	10$
	CLR	CLKFLG
.ENDC
	INC	R5		;COUNT IT
	CMP	R5,#<5.*60.>	;WAITED 5 SEC FOR TTY POWER ?
	BLE	10$		;NOT YET
	PMSG	<\"POWER RESTART" >
	MOV	$PWRCNT,R0
	PNTDEC
	PCRLF
	CLR	R5		;CLEAR TIME-UP COUNTER
2$:	JSR	PC,$TIRDY	;ANY OPERATOR INTERRUPT ?
	BCS	3$		;NO
	MOVB	$TICHR,R4	;YES, GET CHAR
	BICB	#200,R4
	CMPB	#CNTRLC,R4	;IS IT CONTROL C ?
	BEQ	4$		;YES, ABORT TIME-UP WAIT
3$:
.IF NDF SAILVR
	TSTB	(R3)		;CLOCK SET ?
	BPL	2$		;NO
	BIC	#200,(R3)
.IFF
	TST CLKFLG
	BEQ 2$
.ENDC
	INC	R5		;COUNT CLOCK TICK
	CMP	R5,#<5.*60.>	;WAITED 5 SECONDS FOR KL10 ?
	BLE	2$		;NOT YET
4$:	JMP	START
.SBTTL	EXIT SUBROUTINE

$EXITE:	BIS	#CBIT,14(SP)	;SET C-BIT ERROR
	BR	$EXIT

$SETFLG:MOV	@$EMADR,R1		;SET -1 TO FLAG WORD
	MOV	#-1,(R1)

$EXITS:	ADD	#2,12(SP)		;SKIP RETURN
$EXIT:	POP	<R5,R4,R3,R2,R1>
1$:	RTT				;RETURN TO USER

;MEMORY PARITY

MEMPE:	TST	MEMPEF		;BEEN HERE ALREADY ?
	BPL	1$
	FATAL			;YES
1$:	COM	MEMPEF		;SET FLAG
	BIC	#MMPIE,MMLPBA	;CLEAR ENABLE
	BIT	#MMERRF,MMLPBA	;ERROR SET ?
	BNE	2$
	FATAL			;NO, HOW DID THIS GET HERE ?
2$:	PMSG	<?PARITY>
	JMP	$CNTLC
.SBTTL	PDP10 OPERATIONS

;PDP-10 MEMORY ZERO
; R0 = COUNT, R1 = POINTER TO START ADDRESS

$D10ZRO: MOV	R0,R5		;SAVE COUNT
	DEC	R5
	MOV	#.DPXAD,R4
	MOVB	(R1)+,(R4)+
	MOVB	(R1)+,(R4)+
	MOVB	(R1),(R4)
	TST	-(R4)
	CLR	@.DAT1		;CLEAR DTE20 DATA WORDS
	CLR	@.DAT2
	CLR	@.DAT3

$D10ZX: MOV	R4,R1		;POINTER TO ADDRESS
	BR	$DPSX1

;PDP-10 SET -1 TO FLAG WORD
; ADDRESS IN TRAILING PARAMETER

$D10MON: MOV	#L10ADR+2,R1	;SETUP 10 ADR BLOCK POINTER
	CLR	(R1)
	MOV	@$EMADR,-(R1)	;PUT 10 ADR IN ADR BLOCK
	MOV	#TENMO,R0	;SETUP -1 DATA WORD
	ADD	#2,12(SP)	;SKIP RETURN OVER TRAILING PARAMETER
	CLR	R5
	BR	$DPOSX

;EXAMINE AND DEPOSIT 10 MEMORY

$DPOST:	JSR PC,$10ADR		;SETUP PARAMETERS

$DPOS:	CLR R5
	JSR PC,$D10ADR		;SETUP PDP-10 ADDRESS
$DPOSX:	MOV #$TEMP0,R2		;STUFF THE DEXWRDS
	MOVB (R0)+,(R2)+
	MOVB (R0)+,(R2)+
	MOVB (R0)+,(R2)+
	MOVB (R0)+,(R2)+
	MOVB (R0)+,(R2)+
	MOVB (R0),(R2)+
	BIC #177760,-(R2)
	MOV .DAT1,R3
	MOV (R2),(R3)		;BITS 00-03 TO .DAT1
	MOV -(R2),-(R3)		;BITS 04-19 TO .DAT2
	MOV -(R2),-(R3)		;BITS 20-35 TO .DAT3
$DPSX1:	BIS #DEP,2(R1)		;SET FLAG
	BR $EXDEP

$EXAMT:	JSR PC,$10ADR		;SETUP PARAMETERS
	BR $EXAMX

;EXAMINE 10 CORE.  R0 POINTS TO 2 WORDS CONTAINING THE 10 ADDRESS
;	(BITS 20:35 IN FIRST WORD, 14:19 IN SECOND WORD)
;	RESULT RETURNED IN $DRAM (20:35), $DRAM+2 (4:19), $DRAM+4 (0:3)
$EXAM:	MOV R0,R1	
	JSR PC,$D10ADR		;SETUP PDP-10 ADDRESS
	MOV #$DRAM,R0
$EXAMX:	CLR R5
	BIC #DEP,2(R1)		;CLEAR FLAG BIT
$EXDEP:	MOV #EBUSPC,@.STDTE	;E-BUS PARITY CLEAR

.IF EQ EPTREL
	BIS #PHYS!PRTOFF,2(R1)
.IFF
	BIS $TADSP,2(R1)	;$TADSP DESIGNATES ADDR MODE
	MOV #PHYS!PRTOFF,$TADSP	;RESET ADDR MODE FOR NEXT EXDEP
.ENDC
	TST VRBFLG
	BEQ 70$
	BIT #KLRUN,@.DIAG1
	BNE 70$
	PUSH R0
	PUSH @.DAT1		;IF VERBOSE AND KL IS NOT RUNNING THEN USE
	PUSH @.DAT2		;APR FLAGS TO DETERMINE NXM, ETC.
	PUSH @.DAT3
	MOV #$$CLRF,R0
	EXCT			;EXECUTE A CONO APR,23400 TO CLR NXM,IOPGF,MB PAR
	POP @.DAT3
	POP @.DAT2
	POP @.DAT1
	POP R0
70$:	MOV 2(R1),@.TENA1
	MOV (R1),@.TENA2	;START DTE20
	MOV EMTIMO,-(SP)	;SET TIMEOUT COUNT
93$:	BIT #DEXDON,@.STDTE	;TEST BIT
	BNE 94$			;LEAVE IF NOW A ONE(OK)
	DEC (SP)		;DECREMENT COUNT
	BNE 93$			;CONTINUE LOOP
	TST RPTFLG		;OTHERWISE TIMEOUT
	BNE 94$			;UNLESS UNDER REPEAT
	TST VRBFLG
	BEQ 95$
	PUSH R0
	PMSG <EXAM/DEPOSIT TIMEOUT, ADDRESS = >
	MOV R1,R0
	PUSH 2(R0)
	BIC #177700,2(R0)
	PNTADR
	PCRLF
	POP 2(R1)
	POP R0
95$:	CLR TENRUN		;CLEAR TEN RUNNING
	CLR R5			;CLEAR BLOCK ZERO INDICATOR
	BIS #CBIT,16(SP)
94$:	TST VRBFLG
	BEQ 96$
	BIT #KLRUN,@.DIAG1
	BNE 96$			;KL IS STILL RUNNING
	PUSH R0
	PUSH @.DAT1
	PUSH @.DAT2
	PUSH @.DAT3
	MOV #0,-(SP)		;PUSH FLAG
	MOV #110,R0
	DFRD			;BIT 7 IS APR NXM ERR IN
	BIT #BIT12,@.DAT2	;BITS 4-19 (TEST BIT 7)
	BEQ 89$			;BRANCH IF NOT SET
	INC (SP)		;INC FLAG
	PMSG <MBOX DETECTED NXM\>
89$:	BIT #BIT10,@.DAT2	;TEST BIT 9
	BEQ 88$			;EBUS BIT 9 IS APR MB PAR ERR IN
	INC (SP)
	PMSG <MB PARITY ERROR DETECTED\>
88$:	BIT #BIT11,@.DAT2	;TEST BIT 8
	BEQ 87$			;EBUS BIT 8 IS APR I/O PF ERR IN
	INC (SP)
	PMSG <IOPGF (PROB AR PAR ERR) DETECTED\>
87$:	TST (SP)+		;TEST AND FLUSH FLAG, ZERO IF NO ERRORS DETECTED
	BEQ 86$			;BRANCH IF NO ERRORS
	TST RPTFLG
	BEQ 86$
	PMSG <ADDR = >		;ERROR UNDER REPEAT, GIVE ADDRESS
	MOV R1,R0
	PUSH 2(R0)
	BIC #177700,2(R0)
	PNTADR
	PCRLF
	POP 2(R1)
86$:	POP @.DAT3
	POP @.DAT2
	POP @.DAT1
	POP R0
96$:	TST (SP)+		;RESET STACK
	BIT #DEP,2(R1)
	BNE 1$			;DEPOSIT BRANCHES
	PUSH R0
	MOV .DAT3,R3
	MOV (R3)+,(R0)+		;BITS 20-35 FROM .DAT3
	MOV (R3)+,(R0)+		;BITS 04-19 FROM .DAT2
	MOV (R3),(R0)		;BITS 00-03 FROM .DAT1
	BIC #177760,(R0)
	POP R0
	BIT #BPARER,@.STDTE	;E-BUS PARITY ERROR ?
	BEQ 1$			;NO
	BIS #CBIT!VBIT!NBIT!ZBIT,14(SP) ;SET ALL COND BITS
1$:	TST R5			;EXAM, DPOS OR FINISHED BLOCK ZERO ?
	BEQ 2$			;YES
	DEC R5			;BLOCK ZERO, DECREMENT COUNT
	ADD #1,(R4)		;INCREMENT PDP-10 ADDRESS
	ADC 2(R4)
	JMP $D10ZX		;CLEAR NEXT WORD
2$:	EXIT

$$CLRF:	IO10 CONO,APR,,23400	;CLEAR APR NXM, IO PG FAIL, MB PAR ERR
.EVEN
$D10ADR:MOV	#L10ADR,R4
	MOVB	(R1)+,(R4)+
	MOVB	(R1)+,(R4)+
	MOVB	(R1),(R4)
	BIC	#177700,(R4)
	MOV	#L10ADR,R1
	RTS	PC


$EBPAR:	.ASCIZ/?E-BUS PARITY ERROR /
.EVEN

$DPSVT:	JSR	PC,$10ADR	;SETUP PARAMETERS

$DPOSVR:PUSH R0
.IIF NZ EPTREL,	PUSH $TADSP		;PUSH ADDRESS SPACE
	DPOS
	 BCS $DPVRP
.IIF NZ EPTREL,	POP $TADSP		;USE SAME ADDRESS SPACE FOR VERIFY
	MOV R1,R0
	EXAM
	 BCS $DPVRE
	MOV (SP),R0
	PUSH R1				;SAVE ADDRESS
	MOV #$DRAM,R1
	CMPR36
	BCS $DPVRV			;VERIFY ERROR
$DPVRY:	POP R1
$DPVRX:	POP R0
	EXIT

$DPVRP:					;DEPOSIT HALF OF DEPOSIT VERIFY LOST.
.IIF NZ EPTREL, TST (SP)+		;ADJUST STACK (REMOVE ADDR. SPACE)
	BIS #CBIT!NBIT,16(SP)
	BR $DPVRX			;NO, JUST GIVE ERROR RETURN

$DPVRE:	BIS #CBIT!ZBIT,16(SP)		;EXAMINE HALF OF DEPOSIT VERIFY LOST
	BR $DPVRX

$DPVRV:	BIS #CBIT!VBIT,20(SP)		;SET C & V FOR VERIFY ERROR
	TST VRBFLG
	BEQ $DPVRY
	PMSG <\ADDRESS = >
	POP R0
	PNTADR
	PMSG <DEPOSIT DATA = >
	POP R0
	PNT36
	PMSG < EXAMINE DATA = >
	MOV #$DRAM,R0
	PNT36
	PCRLF
	EXIT

;5-BYTE COMPARE ROUTINE, C & V BIT SET IF ERROR

$CMP36:	PUSH	R1
	MOV	#5,R2
1$:	CMPB	(R0)+,(R1)+
	BNE	2$
	DEC	R2
	BNE	1$
	BR	3$
2$:	BIS	#CBIT!VBIT,16(SP)	;SET C & V FOR VERIFY ERROR
3$:	POP	R0			;POINT TO ACTUAL
	EXIT

;PDP-10 ADDRESS PARAMETER SETUP

$10ADR:	MOV	$EMADR,R5	;SETUP TRAILING PARAMETER PICKUP
	MOV	#L10ADR+2,R1	;SETUP 10 ADR BLOCK POINTER
	CLR	(R1)		;CLEAR HI ADR

	MOV	(R5)+,-(R1)	;SETUP PDP-10 ADDRESS
	MOV	(R5),R0		;POINTER TO DATA BLOCK IN R0
	ADD	#4,14(SP)	;RETURN OVER TRAILING PARAMETERS
	RTS	PC
;START MICROCODE

$SM:	PUSH	R0
	MRESET			;RESET KL10
	CLR	R0		;SELECT UCODE START ADR
	WWADR
	DFXCTT			;GET CLOCK GOING
	  STRCLK

	MOV	#2,R1
	MOV	#$SMTAB,R0
1$:	PUSH	R0
	EXCT			;DO TEN INSTR
	 BCS	2$
	POP	R0
	ADD	#5,R0		;NEXT
	DEC	R1
	BNE	1$

	POP	R0
	EXIT

2$:	POP	R0
	POP	R0
$SMERR:	EXITERR

$SMTAB:	IO10	CONO,APR,,200000	;IO SYS CLEAR
	IO10	CONO,PI,,10000		;PI SYS CLEAR
	.EVEN
;PDP-10 INSTRUCTION EXECUTE

$XCT:	LODAR
	 BCS	6$
	DFXCTT			;SET CONTINUE BUTTON
	  CONBUT
	DFXCTT			;RUN THE CLOCK
	  STRCLK

	TST	RPTFLG		;DOING REPEAT ?
	BNE	2$		;YES, NO CHECK

	MOV	#1000.,R1
4$:	BIT	#HALTLP,@.DIAG1
	BNE	2$
	DEC	R1		;NO, WAITED LONG ENOUGH
	BNE	4$
6$:	BR	$SMERR

2$:	EXIT

;ECLOK - GIVE A COMPLETE EBOX CLOCK

$ECLOK:	MOV	#4000.,R5

91$:	DFSCLK			;STEP RAW CLOCK
	DFRDT			;READ CLOCK STATE
	104
	BIT	#BIT2,@.DAT3	;CLK E BOX SOURCE HIGH ?
	BNE	92$
	DEC	R5
	BNE	91$
	TST	RPTFLG
	BNE	92$
	BIS	#CBIT,14(SP)	;REPORT TIMEOUT

92$:	DFXCTT
	  CECLK
	EXIT
;PDP-10 CONTROLLED STOP ROUTINE

$TENSP:	PUSH	R0
	CLR	TENRUN		;CLEAR LOGICAL TEN RUNNING FLAG
;;;;;	CLR	TENCLK		;CLEAR TEN USING CLOCK FLAG
;;;;;	DON'T CLEAR TENCLK.  YOU MIGHT WANT TO CONTINUE THE SYSTEM

	MOV	#DCOMST!DFUNC!<CLRRUN*1000>,@.DIAG1
	JSR	PC,$$DFXDN	;CLEAR RUN FLOP

	MOV	#1000.,R1
1$:	BIT	#HALTLP,@.DIAG1
	BNE	2$		;TEN RETURNED TO HALT LOOP
	DEC	R1
	BNE	1$
	BR	5$		;FAILED TO RETURN TO HALT LOOP

2$:	DFRDT
	  131
	BIT	#BIT1,@.DAT2	;BIT 18, CON CACHE LOOK
	BEQ	4$		;FALSE, CACHE IS NOT ON

	MOV	#$$CF,R0
	EXCT			;EXECUTE CACHE FLUSH
	  BCS	5$		;FAILED

	MOV	#1000.,R1
3$:	DFRDT
	  110
	BIT	#BIT2,@.DAT1	;BIT 1, SWEEP BUSY ENABLE
	BEQ	4$		;FINISHED SWEEP
	DEC	R1
	BNE	3$
	BR	5$		;FAILED TO FINISH CACHE SWEEP

4$:	POP	R0		;SUCESSFUL RETURN
	EXIT

5$:	POP	R0		;FAILED RETURN
	EXITERR
	.SBTTL	CLOCK INITIALIZATION, INTERRUPTS
.IF DF SAILVR

CLKSTA:	PUSH R0
	MOV #KWLIV,R0
	MOV #CLKINT,(R0)+
	MOV #CPUPR,(R0)
	CLR KTIMBS		;ASSUME WE'RE NOT KEEPING TIMEBASE
	MOV #TIMBAS,R0
	CLR (R0)+
	CLR (R0)+
	CLR (R0)
	MOV #TIM11,R0
	CLR (R0)+
	CLR (R0)+
	CLR (R0)
	CLR CLKFLG
	BIC #300,KWLKS		;CLEAR CLOCK FLAG AND INTERRUPT ENABLE
1$:	TSTB KWLKS
	BPL 1$			;LOOP UNTIL CLOCK FLAG COMES ON
	BIC #200,KWLKS		;CLEAR CLOCK FLAG
	BIS #100,KWLKS		;SET INTERRUPT ENABLE.
	POP R0
	RTS PC


CLKINT:	BIC #200,KWLKS		;CLEAR CLOCK FLAG
	INC CLKFLG		;INCREMENT SOFTWARE CLOCK FLAG
	INC TIM11
	ADC TIM11+2
	ADC TIM11+4
	TST FSCLKA
	BEQ 3$			;NO FS CLOCK REQUESTS
	CMP TIM11+4,FSRTIM+4
	BGT 2$
	BNE 3$
	CMP TIM11+2,FSRTIM+2
	BGT 2$
	BNE 3$
	CMP TIM11,FSRTIM
	BLT 3$
2$:	PUSH R0
	MOV FSCLKA,R0
	CLR FSCLKA
	JSR PC,@R0
	POP R0
3$:	TST KTIMBS
	BEQ 4$			;JUMP IF NOT KEEPING A TIMEBASE
	INC TIMBAS
	ADC TIMBAS+2
	ADC TIMBAS+4
4$:	BIT #DLRTS,@$FSTKS	;SEE IF REQUEST TO SEND IS UP (CLEARED BY INIT)
	BNE 5$			;YES, HAVEN'T BEEN RESET
	JSR PC,HANGU1
5$:	TST TIMFLG		;DOES KL WANT TIME/DATE FROM BATTERY CLOCK?
	BEQ 6$			;NO
	BIT #7777,TIM11		;IS IT TIME YET? (EVERY 10000 TICS=1.13 SECS)
	BNE 6$			;NO
	INC TMSFLG		;TELL C10COP TO STORE THE TIME
6$:	RTT			;DISMISS INTERRUPT

.ENDC
