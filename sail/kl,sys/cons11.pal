COMMENT ⊗   VALID 00061 PAGES
C REC  PAGE   DESCRIPTION
C00001 00001
C00006 00002	.SBTTL	CONSOLE PACKAGE FOR KL10/11 INTERFACE, 9-SEPT-75
C00008 00003	$KONSL:	TTIBRK			GET BREAK CHAR FROM LAST OPERATION
C00010 00004	$$CONSL:CLR	RPTFLG		Start here from 100014
C00013 00005	3$:	MOVB	#40,$KDCEN+1	MAKE SINGLE LETTER COMMAND
C00015 00006	.SBTTL	CONSOLE DISPATCH TABLE
C00023 00007	DISPATCH TABLE
C00028 00008	.SBTTL	DIAGNOSIC CONSOLE UTILITY COMMAND PROCESS
C00030 00009	.SBTTL	CONSOLE COMMAND REPEAT CONTROL
C00031 00010	.SBTTL	PROGRAM CONSOLE COMMAND PROCESS
C00033 00011	PROGRAM INDIRECT CCL FILE PROCESS
C00035 00012	.SBTTL	DIAGNOSTIC FUNCTIONS
C00037 00013	DIAGNOSTIC READ AND PRINT
C00038 00014	.DFDP:	DFLEGAL			FUNCTION LEGAL ?
C00039 00015	.AR:	TTICHR
C00040 00016	.BR:	TTICHR
C00042 00017	.PC:	TTICHR
C00043 00018	.VM:	DFLEGAL			FUNCTION LEGAL ?
C00044 00019	PCF COMMAND - PRINT PC FLAGS
C00047 00020	.FE:	TTITRM
C00048 00021	PRINT PRIORITY INTERRUPT FUNCTIONS
C00050 00022	PRINT ALL - C-RAM & REGISTERS
C00052 00023	.SBTTL	PDP-10 START/STOP FUNCTIONS
C00054 00024	START PDP-10 DDT
C00057 00025	PULSE THE E-BOX CLOCK
C00059 00026	EXECUTE A PDP10 INSTRUCTION.
C00060 00027		PNTCPU			PRINT C-RAM & REGISTERS
C00062 00028	SELECT CLOCK SOURCE
C00063 00029	PROCESSOR PARITY DISABLE
C00064 00030	PROCESSOR PARITY ENABLE
C00066 00031	MICRO-CODE SYNC MARK ROUTINES
C00067 00032	MICRO-CODE TIME FIELD CHANGE ROUTINE
C00068 00033	CACHE ENABLE
C00070 00034	AC BLOCK SELECTION
C00073 00035	START PDP10 AT ADDRESS SPECIFIED AS LOWER 18 BITS OF 36-BIT ARGUMENT.
C00077 00036	.SBTTL	PDP-10 DEPOSIT AND EXAMINE CONSOLE FUNCTIONS
C00079 00037	MEMORY ZERO
C00081 00038	.EXM:	MOV	#.DPXAD,R5
C00083 00039	.SBTTL	CONSOLE IDLE RUN LOOP
C00086 00040	MONITOR TELETYPE CHARACTER INPUT -- MTTYIN MTTYI0 MTTYI1 C10DN1 MTTYER MTTYOC MTTYO MTTYP MTTYX MTTYC MTTYCF $MC MTTYS C10DN2
C00089 00041	.SBTTL	PDP-10 RUN TIME SUPPORT		TENCMD CMD10T C10DON
C00091 00042	C10DNX, TENCERR
C00093 00043	C10TO, C10TI
C00095 00044	Switch functions.  C10SW
C00098 00045	C10PRG C10PT C10P2 C10P1 C10X1 C10P3 C10P4 C10P5 C10KAS KASET
C00100 00046	Clock operations.  C10CLK
C00110 00047	PDP-10 SWITCH REGISTER
C00112 00048	.SBTTL	PDP-10 PROGRAM COMMAND
C00114 00049	"DIAMON" FILE READ
C00116 00050	.SBTTL	PDP-11 CONSOLE FUNCTIONS
C00117 00051	EXAMINE ELEVEN AT ADDRESS GIVEN
C00120 00052	DEPOSIT ELEVEN DATA
C00121 00053	.SBTTL	KL10 MONITOR & ACT10 COMMAND ROUTINES
C00123 00054	.IF DF MONASB
C00125 00055	SRT11X:	MOV	PGOADR,SEADR
C00127 00056	.IF DF MONASB
C00129 00057	ADRERR:	PMSG	<?ADR>
C00130 00058	.SBTTL	LINE PRINTER SELECTION ROUTINE
C00134 00059	.SBTTL	CONSOLE TELETYPE FUNCTIONS
C00135 00060	.SBTTL	KLINIK FIELD SERVICE REMOTE DIAGNOSTICS ENABLE
C00137 00061	 FSRLEN FSRINT FSINT1 FSXIT FSINT2 FSXITC FSINTA FSINT3 FSINT4 FSXITA FSIN4R FSIN4D FSIN4E FSIN4W HANGUP HANGU1 FSHNG1 FSINT5 FSIN5A FSTINT FSTYP FSTYP1 FSTYP2 FSCLKR FSMSG FSLOSM PWORD PWLEN $HU
C00145 ENDMK
C⊗;
.SBTTL	CONSOLE PACKAGE FOR KL10/11 INTERFACE, 9-SEPT-75

CONSL:	MOV	#CPUPR,PS	;SET CPU PRIORITY.
	MOV	#STACK,SP	;RESET STACK
	MOV	#$STUF,R0	;SETUP FOR STACK UNDERFLOW
	MOV	R0,(SP)
1$:	PUSH	R0

	MOV	SP,$KONSP

KONSL:	MOV	$KONSP,SP	;RESET STACK POINTER

.IIF NE EPTREL,	MOV	#PHYS!PRTOFF,$TADSP	;DEFAULT ADDR MODE FOR EXDEP

	TTPINI			;INIT TTY POINTERS

	CLR	DDTFLG
	CLR	IFILEF
	CLR	HLPPNT
	CLR	PCMDFLG
	PFORCE			;ALL OUTPUT TO TTY

	JSR	PC,$CKSUM	;COMPUTE CHECKSUM OF "KLDCP"

	CMP	R0,$ILDSUM	;DOES IT MATCH AS LOADED ?
	BEQ	2$		;YES, OK !!!!

	MOV	R0,$ILDSUM	;NO, ONLY REPORT CHANGES
	PMSG	<?"KLDCP" CKSUM\>

2$:	TST	JFILEF
	BNE	$$CONSL
	PMSG	<CMD:\>
	BR	$$CONSL
$KONSL:	TTIBRK			;GET BREAK CHAR FROM LAST OPERATION
	 BCS	$KONS1		;NO DATA
	CMPB	#',,R0		;WAS LAST BREAK A COMMA ?
	BEQ	$RPT		;BR IF YES, CONTINUE STRING PROCESS
	CMPB	#' ,R0		;WAS LAST BREAK A SPACE ?
	BEQ	$RPT		;YES, CONTINUE STRING PROCESS
	CMPB	#TAB,R0		;WAS LAST BREAK A TAB ?
	BEQ	$RPT		;YES, CONTINUE STRING PROCESS
	TST	R0
	BEQ	11$		;NULL, EOL
	CMP	#LF,R0		;IS IT LF ?
	BEQ	11$		;YES
	CMP	#ALTMOD,R0
	BEQ	11$		;IS IT ALTMODE ?
	CMP	#CR,R0		;IS IT A CR ?
	BNE	2$		;NO, INVALID TERMINATION

11$:	TST	RPTFLG		;PRESENTLY DOING A REPEAT ?
	BEQ	$KONS1		;BR IF NO

	JSR	PC,$PTTYC	;CHECK OPERATOR INTERRUPT

1$:	MOV	#$INBUF+2,$INPTC	;REPEAT, REDO COMMAND
	BR	$RPT

2$:	JMP	$CMDER
$$CONSL:CLR	RPTFLG		;Start here from 100014
	CLR	DVDIRF		;CLEAR DEVICE DIRECTORY FLAG

				;IN CASE OF START AT 100000+X FROM CONSOLE
.IF DF TELASB
	BIT #DLRTS,@$FSTKS
	BNE 1$			;RTS STILL SET, ASSUME OK
	JSR PC,HANGU1		;RTS OFF, MUST HAVE BEEN RANDOM INIT, SO HANGUP
1$:
.ENDC ;DF TELASB
.LIF DF SAILVR
	BIS #100,KWLKS		;SET CLOCK INTERRUPT ENABLE

$KONS1:	TST	PCMDFLG		;DOING PROGRAM COMMAND ?
	BEQ	1$		;NO
	JMP	PCMDE		;YES, RETURN TO PROGRAM
1$:	TST	IFILEF		;PROCESSING INDIRECT FILE ?
	BEQ	2$		;NO
	JMP	IFILIN		;YES, GET CHARS FROM STORAGE
2$:	TST	JFILEF		;DOING DOUBLE INDIRECT ?
	BPL	$KONS2		;NO
	JMP	JFILIN		;YES, GET CHARS FROM STORAGE
$KONS2:	MOV	SP,$KONSP	;SAVE STACK POINTER
1$:	PFORCE
	PNTCI
	'>
	PMSG	<. ←>
2$:	RUNLP			;RUN LOOP &/OR READ IN A TTY LINE
	 BCC	$RPT		;RESPONSE, GO PROCESS
	CMP	#$INBUF,$INPTR	;ANYTHING BEEN TYPED ?
	BNE	1$		;YES, REPROMPT
	BR	2$

$RPT:	CLR	ALLFLG		;CLEAR ALL PRINT FLAG
	TTISDL			;READ ONE CHARACTER
	 BCC	$CMDER		;...NUMBER, ILLEGAL
1$:	CMPB	#';,R0
	BEQ	$$CONSL		;SEMICOLON, LOCAL COPY ONLY
	CMPB	#'.,R0
	BEQ	$RPT		;DOT, IGNORE
	MOVB	R0,$KDCEN	;PLACE IN END OF DECODER

	TTICHR			;READ SECOND CHARACTER
	 BCS	$KONS1		;EVEN 1 CHAR CMDS ARE 2 CHAR MIN.
	CMPB	#12,R0		;IF THIS CHAR IS A LINE FEED
	BEQ	$KONS1		;..1ST CHAR MUST HAVE BEEN CR, IGNORE
	CMPB	#15,R0		;IF THIS CHAR A CR
	BEQ	3$		;THIS IS A SINGLE LETTER COMMAND
	CMPB	#33,R0		;IF ALTMODE
	BEQ	3$		;       DITTO
	MOVB	R0,$KDCEN+1	;PLACE SECOND IN END OF DECODER

;THE COMMAND PORTION OF THE INPUT STRING IS READY TO BE DECODED

4$:	MOV	$KDCEN,R0	;COMMAND TO R0
	MOV	#$KDCRE,R1	;ADDRESS OF LIST TO R1

2$:	CMP	R0,(R1)+	;TEST FOR COMMAND
	BNE	2$		;NOT FOUND YET
	CLR	$KDCEN
.LIF DF MONASB
	CLR	ENQFLG
	JMP	@$DISPH-$KDCRE-2(R1)	;EXIT TO SELECTED SUBROUTINE
3$:	MOVB	#40,$KDCEN+1	;MAKE SINGLE LETTER COMMAND
	BR	4$		;LETTER & SPACE FOR LOOKUP

$CMDER:	PNTCI
	'?
	BR	$$$CC

$$CNTLC:CLR	DIAFLG
	CLRB	TENRUN		;CLEAR PDP-10 RUNNING FLAG
	TST	PCMDFLG		;DOING PROGRAM COMMAND ?
	BNE	$$$CC		;YES
	CLR	PRGRUN		;CLEAR PROGRAM RUNNING FLAG
$$$CC:	SETFLG
	  $TTLKF
	TST	DEVTYP		;IN ACT10 MODE ?
	BPL	1$		;NO
.IF DF MONASB
	TST	ENQFLG		;DOING APT10 COMMAND ?
	BEQ	1$		;NO
	COMCLR			;ACT10, CLEAR COMM, THEN TO CONSL
.ENDC
1$:	PUSH	$FORCE		;SAVE FORCED PRINTING FLAG
	PFORCE
	PCRLF			;FORCE PRINT ERROR
	POP	$FORCE		;RESTORE

	TST	PCMDFLG		;DOING PROGRAM COMMAND ?
	BEQ	2$		;NO
	JMP	PCMDE1		;YES, TAKE ERROR RETURN

2$:	CLR	JFILEF		;CLEAR DOUBLE INDIRECT FLAG
	JMP	KONSL
.SBTTL	CONSOLE DISPATCH TABLE

$KDCRE:	.ASCII	/R /		;REPEAT OPERATOR
	.ASCII	/FX/		;DIAGNOSTIC FUNCTION EXECUTE
	.ASCII	/FW/		;DIAGNOSTIC FUNCTION WRITE
	.ASCII	/FR/		;DIAGNOSTIC FUNCTION READ
	.ASCII	/FS/		;DIAGNOSTIC FUNCTION SYNC
	.ASCII	/DA/		;DIAGNOSTIC DEPOSIT INTO AR
	.ASCII	/EX/		;PDP-10 INSTRUCTION EXECUTE
	.ASCII	/MR/		;MASTER RESET

;PDP-10 EXAMINE/DEPOSIT FUNCTIONS

	.ASCII	/EM/		;EXAMINE 10 AT ADR AND PRINT
	.ASCII	/DM/		;DEPOSIT DATA IN 10 ADDRESS
	.ASCII	/EN/		;EXAMINE AND PRINT NEXT 10 ADDRESSES
	.ASCII	/DN/		;DEPOSIT DATA INTO NEXT 10 ADDRESSES
	.ASCII	/MZ/		;MEMORY ZERO

;START/STOP FUNCTIONS

	.ASCII	/SP/		;STOP 10, CLEAR RUN FLOP
	.ASCII	/RN/		;START 10, SET RUN FLOP
	.ASCII	/SI/		;SINGLE INSTRUCTION,PUSH CONTINUE
	.ASCII	/PL/		;PULSE CLOCK
	.ASCII	/BU/		;BURST CLOCK
	.ASCII	/SM/		;START MICRO CODE,SUPPORT EXAMINE/DEPOSIT
	.ASCII	/ST/		;START AT 10 ADDRESS
	.ASCII	/SW/		;PDP-10 SWITCHES
	.ASCII	/AC/		;"AC BLK" SELECTION
	.ASCII	/MC/		;PDP-10 MONITOR CONTINUE
.LIF DF %%EOP
	.ASCII	/EP/		;SET EOP INTERVAL

;PDP-11 FUNCTIONS

	.ASCII	/SE/		;START 11 AT ADR
	.ASCII	/EE/		;EXAMINE 11 AT ADR AND PRINT
	.ASCII	/DE/		;DEPOSIT DATA IN 11 ADDRESS
	.ASCII	/EB/		;EXAMINE 11 BYTE
	.ASCII	/DB/		;DEPOSIT 11 BYTE
	.ASCII	/ZE/		;ZERO ELEVEN

;RAM FUNCTIONS

	.ASCII	/EC/		;EXAMINE C-RAM AT ADDRESS AND PRINT
	.ASCII	/DC/		;DEPOSIT DATA INTO C-RAM ADDRESS
	.ASCII	/RC/		;READ C-RAM, FR'S 140-141-142-143
	.ASCII	/ED/		;EXAMINE D-RAM AT ADDRESS AND PRINT
	.ASCII	/DD/		;[START DDT] OR DEPOSIT D-RAM
	.ASCII	/MM/		;MICRO-CODE SYNC MARK
	.ASCII	/MU/		;MICRO-CODE SYNC UNMARK
	.ASCII	/MT/		;MICRO-CODE TIME CHANGE

;CLOCK OPERATIONS

	.ASCII	/CS/		;CLOCK SOURCE
	.ASCII	/CR/		;CLOCK RATE

;PROCESSOR PARITY FUNCTIONS

	.ASCII	/PD/		;DISABLE PARITY STOP
	.ASCII	/PE/		;ENABLE PARITY STOP

;INTERNAL E-BOX REGISTER READ FUNCTIONS

	.ASCII	/AR/		;READ & PRINT AR REGISTER
	.ASCII	/BR/		;READ & PRINT BR REGISTER
	.ASCII	/MQ/		;READ & PRINT MQ REGISTER
	.ASCII	/FM/		;READ & PRINT FM REGISTER
	.ASCII	/AD/		;READ & PRINT ADDER
	.ASCII	/PC/		;READ & PRINT PC
	.ASCII	/VM/		;READ & PRINT VMA
	.ASCII	/SC/		;READ & PRINT SC REGISTER
	.ASCII	/FE/		;READ & PRINT FE REGISTER
	.ASCII	/ER/		;READ & PRINT E-BUS REGISTER
	.ASCII	/PI/		;READ & PRINT PI SYSTEM
	.ASCII	/AL/		;PRINT ALL, C-RAM & REGISTERS

;CACHE OPERATIONS

	.ASCII	/CE/		;CACHE ENABLE
	.ASCII	/CI/		;CACHE INVALIDATE
	.ASCII	/CF/		;CACHE FLUSH

;REPEAT CONTROL

	.ASCII	/RP/		;REPEAT & PRINT OR RP04 SELECT
	.ASCII	/TD/		;TIME DELAY

;CONSOLE (TTY) CONTROL FUNCTION

	.ASCII	/TP/		;SET TTY PAGE LENGTH
	.ASCII	/TW/		;SET TTY PAGE WIDTH
	.ASCII	/TF/		;SET TTY FILL COUNT

.LIF DF UTLASB
	.ASCII	/TT/		;SWITCH TO REMOTE TELETYPE OPERATION

.LIF DF LPASB
	.ASCII	/LP/		;LINE PRINTER SELECTION

.IF NDF TELASB
	.ASCII	/KL/		;KLINIK SELECTION
.IFF
	.ASCII /HU/		;HANGUP
.ENDC

;KL10 MONITOR (PROGRAM & ACT10) COMMANDS

.IF DF MONASB
	.ASCII	/B /		;BOOT
	.ASCII	/LI/		;LOGIN
.ENDC
	.ASCII	/H /		;HELP
	.ASCII	/P /		;PROGRAM
	.ASCII	/LT/		;LOAD TEN
	.ASCII	/LE/		;LOAD ELEVEN
	.ASCII	/LR/		;LOAD RAM
	.ASCII	/LB/		;LOAD ELEVEN BINARY

.LIF DF BOOASB
	.ASCII	/LD/		;LOAD DSKDMP BOOTSTRAP LOADER

	.ASCII	/V /		;VERFIY PROGRAM
	.ASCII	/C /		;COMMENT/CORRECTIVE ACTION
.IF DF MONASB
	.ASCII	/S /		;SCRIPT
	.ASCII	/M /		;MASTER SCRIPT
	.ASCII	/LO/		;LOGOUT
	.ASCII	/GS/		;GENERATE SCRIPT
.ENDC
	.ASCII	/GO/		;GO START PROGRAM
;;;;	.ASCII	/CD/		;PDP-11 CORE DUMP

.IF DF RPASB
.IF DF UTLASB
	.ASCII	/TA/		;ACT10 TO RP04 TRANSFER
	.ASCII	/WF/		;DECTAPE TO RP04 WRITE
.ENDC
	.ASCII	/RE/		;'RENM' RENAME RP04 FILE
.ENDC

.IF DF MONASB
	.ASCII	/T /		;TIME
	.ASCII	/BT/		;BOOT TEN
	.ASCII	/AT/		;SWITCH TO ACT10 MODE
.ENDC

	.ASCII	/DT/		;SWITCH TO DECTAPE MODE, SELECT UNIT

.LIF DF RXASB
	.ASCII	/RX/		;SWITCH TO FLOPPY MODE, SELECT UNIT

	.ASCII	/DI/		;DIRECTORY, DECTAPE/RP04/FLOPPY

.IF DF BPTASB
	.ASCII	/BP/		;BREAKPOINT TRAP LAYER
	.ASCII	/BC/		;BREAKPOINT CONTINUE
	.ASCII	/RG/		;TYPE OUT BREAK STUFF
	.ASCII	/RB/		;REMOVE BREAKPOINTS
.ENDC

	.ASCII	/HC/		;ERROR HALT CONTINUE

	.ASCII	/RI/		;REINITIALIZE SYSTEM

	.ASCII	/I /		;INDIRECT COMMAND FILE PROCESS
	.ASCII	/J /		;DOUBLE INDIRECT COMMAND FILE
	.ASCII	/JC/		;"J" FILE CONTINUE

.LIF DF BOOASB
	.ASCII	/DS/		;LOAD DSKDMP BOOTSTRAP INTO 10 MEM AND START
	.ASCII  /VB/		;COMPLEMENT VERBOSE FLAG
	.ASCII	/KA/		;ENABLE KASIM

$KDCEN:	0			;ERROR TRAP FOR NONEXISTANT COMMANDS
;DISPATCH TABLE

$DISPH:	.RPT			;REPEAT OPERATION
	.DFXCT			;DIAGNOSTIC FUNCTION EXECUTE
	.DFWRT			;   "         "      WRITE
	.DFRD			;   "         "      READ
	.FS			;   "         "      SYNC
	.DA			;   "       DEPOSIT INTO AR
	.XCT			;EXECUTE 10 INSTRUCTION
	.MRESET			;MASTER RESET
	.EXM			;EXAMINE 10
	.DP			;DEPOSIT 10
	.EXMNX			;EXAMINE NEXT 10
	.DPNX			;DEPOSIT NEXT 10
	.MZ			;MEMORY ZERO
	$SP			;STOP 10
	$RN			;RUN 10
	$SI			;SINGLE INSTRUCT 10
	.PL			;PULSE 10
	.BU			;BURST CLOCK
	.SM			;START MACHINE
	$ST			;START 10
	$SW			;SWITCHES 10
	.AC			;"AC BLK" SELECTION
	$MC			;MONITOR CONTINUE
.LIF DF %%EOP
	.EP			;SET EOP INTERVAL
	.SE			;START ELEVEN
	.EE			;EXAMINE ELEVEN
	.DE			;DEPOSIT ELEVEN
	.EB			;EXAMINE 11 BYTE
	.DB			;DEPOSIT 11 BYTE
	.ZE			;ZERO ELEVEN
	$EC			;EXAMINE C←RAM
	$DC			;DEPOSIT C-RAM
	$RC			;READ C-RAM
	$ED			;EXAMINE D←RAM
	$DDTX			;[START DDT] OR DEPOSIT D←RAM
	.MM			;MICRO-CODE MARK
	.MU			;MICRO-CODE UNMARK
	.MT			;MICRO-CODE TIME CHANGE
	.CS			;SELECT CLOCK SOURCE
	.CR			;SELECT CLOCK RATE
	.PD			;PROCESSOR PARITY DISABLE
	.PE			;PROCESSOR PARITY ENABLE
	.AR			;READ REGISTERS
	.BR
	.MQ
	.FM
	.AD
	.PC
	.VM
	.SC
	.FE
	.ERG
	.PI			;READ & PRINT PI SYSTEM
	.ALL			;PRINT ALL
	.CE			;CACHE ENABLE
	.CI			;CACHE INVALIDATE
	.CF			;CACHE FLUSH
	.RPTP			;REPEAT & PRINT
	.TD			;TIME DELAY
	$TP			;SET TTY PAGE LENGTH
	$TW			;SET TTY PAGE WIDTH
	$TF			;SET TTY FILL PARAMETER
.LIF DF UTLASB
	$TT			;SWITCH TO REMOTE TTY

.LIF DF LPASB
	$LPT			;LINE PRINTER SELECTION

.IF NDF TELASB
	.KLINIK			;KLINIK SELECTION
.IFF
	$HU			;HANG UP
.ENDC

;KL10 MONITOR (PROGRAM & ACT10) COMMANDS

.IF DF MONASB
	$BOOT			;BOOT SYSTEM
	$LOGIN			;LOG IN
.ENDC
	$HELP			;HELP
	$PROG			;LOAD PROGRAM
	$LDT			;LOAD TEN
	$LDE			;LOAD ELEVEN
	$LDR			;LOAD RAM
	$LDB			;LOAD ELEVEN BINARY

.LIF DF BOOASB
	$LDD			;LOAD DSKDMP BOOT

	$VERIFY			;VERIFY PROGRAM
	$COMNT			;COMMENT
.IF DF MONASB
	$SCRPT			;SCRIPT REQUEST
	$MSCP			;MASTER SCRIPT REQUEST
	$LOGO			;LOG OUT
	$GSCP			;GENERATE SCRIPT
.ENDC
	$GO			;PROGRAM GO
;;;;	$CD			;PDP-11 CORE DUMP

.IF DF RPASB
.IF DF UTLASB
	$TA			;ACT10 TO RP04 TRANSFER
	$WF			;DECTAPE TO RP04 WRITE FILE
.ENDC
	$RE			;'RENM' RP04 RENAME FILE
.ENDC

.IF DF MONASB
	$TIME			;TIME
	$BOOTT			;BOOT PDP-10
	$AT			;SELECT ACT-10 MODE
.ENDC
	$DT			;SELECT DECTAPE MODE & UNIT

.LIF DF RXASB
	$RX			;SELECT FLOPPY MODE & UNIT

	$DI			;DIRECTORY, DECTAPE/RP04/FLOPPY

.IF DF BPTASB
	.BP			;BREAKPOINT INSERTION
	.BC			;BREAKPOINT CONTINUE
	.RG			;PRINT SAVED REGISTERS
	.RB			;REMOVE BREAKPOINTS
.ENDC

	.HC			;HALT CONTINUE
	.RI			;REINITIALIZE CONSOLE
	$IFILE			;INDIRECT FILE
	$JFILE			;DOUBLE INDIRECT FILE
	$JC			;J FILE CONTINUE

.LIF DF BOOASB
	$DS			;LOAD AND START DSKDMP BOOTSTRAP PROGRAM
	$VB			;COMPLEMENT VERBOSE TYPEOUT
	$KA			;ENABLE KASIM

	$CMDER			;NO SUCH COMMAND
.SBTTL	DIAGNOSIC CONSOLE UTILITY COMMAND PROCESS

.IF DF UTLASB

;UTILITY PROGRAM CHECK

$KLUCK:	CMP	PID,PIDU	;UTILITY PROGRAM IN CORE ?
	BNE	1$
	CMP	PID+2,PIDU+2
	BNE	1$
	CMP	PDVER,#DECVER	;PROPER VERSION ?
	BNE	1$
	RTS	PC		;OK

1$:	PMSG	<PLEASE LOAD "KLDCPU.A11" FIRST>
	JMP	$CNTLC

PIDU:	.RAD50	/KLDCPU/

;TRANSFER FROM APT10 DISPATCH

$TA:	JSR	PC,$KLUCK	;UTILITY IN CORE ?
	JMP	@TAPT		;YES

;WRITE FILE FROM DTA/FLOPPY DISPATCH

$WF:	JSR	PC,$KLUCK	;UTILITY IN CORE ?
	JMP	@WFILE		;YES

;REMOTE TELETYPE COMMUNICATIONS DISPATCH

$TT:	JSR	PC,$KLUCK	;UTILITY IN CORE ?
	JMP	@REMOTE		;YES

;RP04 DISK DIRECTORY DISPATCH

.IF DR RPASB
$RPDIR:	JSR	PC,$KLUCK	;UTILITY IN CORE ?
	JMP	@DSKDIR		;YES
.ENDC

.ENDC
.SBTTL	CONSOLE COMMAND REPEAT CONTROL

.RPT:	SETFLG
	  RPTFLG		;SET REPEAT FLAG

.RPTX:	PNORML
	JMP	$RPT

.RPTP:	TTISDL
	 BCC	1$		;NUMBER
	TTBACK
	MOV	#177400,RPTFLG	;SET REPEAT & PRINT
	BR	.RPTX

1$:	JMP	$RP		;MUST BE RP04 SELECTION

.IIF NDF RPASB,$RP==$CMDER
.SBTTL	PROGRAM CONSOLE COMMAND PROCESS

$PRGNPT:SETFLG			;PROGRAM COMMAND, NO PRINT
	  PCMDNF
	BR	$PRGXX
$PRGCMD:CLR	PCMDNF
$PRGXX:	SETFLG
	  PCMDFLG		;SET PROGRAM COMMAND FLAG
	TST	R0
	BEQ	2$		;USE CURRENT INPUT BUFFER, R0=0
	CMP	#-1,R0
	BNE	3$
	MOV	#$OUTBF,R0	;USE OUTPUT BUFFER, R0 = -1
	MOV	R0,$OUTPT
3$:	JSR	PC,$PCMDX	;TRANSFER COMMAND TO INPUT BUFFER
2$:	MOV	#$INBUF,$INPTC	;SET PICKUP POINTER
	MOV	SP,$$SVSP	;SAVE STACK POINTER
	JMP	$RPT		;PROCESS COMMAND

PCMDE:	MOV	$$SVSP,SP	;RESTORE STACK POINTER
	CLR	PCMDFLG
	CLR	PCMDNF
.LIF DF MONASB
	CLR	ENQFLG
	EXIT
PCMDE1:	MOV	$$SVSP,SP
PCMDE3:	CLR	PCMDFLG		;ERROR, C-BIT SET RETURN
	CLR	PCMDNF
	CLR	HLPPNT
	EXITERR
PCMDE2:	MOV	$$SVSP,SP
	BIS	#NBIT,14(SP)	;CONTROL C DURING TYPEOUT
	BR	PCMDE3		;NBIT & CBIT SET RETURN

$PCMDX:	MOV	#$INBUF,R1	;MOVE COMMAND TO INPUT BUFFER
$DIASX=.
1$:	MOVB	(R0)+,(R1)+	;TRANSFER CHARS
	BNE	1$		;TILL NULL
	DEC	R1
	MOVB	#CR,(R1)+
	MOVB	#LF,(R1)+
	MOV	R1,$INPTR	;SAVE EOL POINTER
	RTS	PC
;PROGRAM INDIRECT CCL FILE PROCESS

$TTICCL:MOV	IFINP,R1	;XFER CHARS INTO INPUT BUFFER
	TSTB	(R1)		;FIRST CHAR A NULL ?
	BEQ	1$		;YES, FINISHED
	JSR	PC,IJFILX
	MOV	R1,IFINP	;RESAVE POINTER
	EXIT
1$:	EXITERR			;FINISHED, C-BIT SET RETURN

;INDIRECT COMMAND FILE PROCESS

IFILIN:	MOV	IFINP,R1	;XFER CHARS INTO INPUT BUFFER
	TSTB	(R1)		;FIRST CHAR A NULL ?
	BEQ	IFILX1		;YES, FINISHED
	JSR	PC,IJFILX
	MOV	R1,IFINP	;RESAVE STORAGE POINTER
	TST	JFILEF		;DON'T PRINT "I" IF UNDER "J"
	BNE	3$
IFILX=.
	$PMSG			;PRINT COMMAND LINE
	$INBUF
3$:	JMP	$RPT		;GO PROCESS

IFILX1:	JMP	CONSL		;FINISHED

;DOUBLE INDIRECT COMMAND FILE PROCESS

JFILIN:	TST	PRGRUN		;PROGRAM PRESENTLY RUNNING ?
	BEQ	3$		;NO
	JMP	$KONS2		;YES, WAIT TILL IT'S DONE
3$:	MOV	JFINP,R1	;XFER CHARS INTO INPUT BUFFER

	TSTB	(R1)		;FIRST CHAR A NULL ?
	BEQ	2$		;YES, FINISHED

	JSR	PC,IJFILX
	MOV	R1,JFINP	;RESAVE STORAGE POINTER
	BR	IFILX

2$:	CLR	JFILEF
	BR	IFILX1

IJFILX:	MOV	#$INBUF,R0
	MOV	R0,$INPTC

1$:	MOVB	(R1)+,(R0)+
	BNE	1$

	MOV	R0,$INPTR
	RTS	PC
.SBTTL	DIAGNOSTIC FUNCTIONS

;DIAGNOSTIC FUNCTION EXECUTE

.DFXCT:	DFLEGAL			;FUNCTION LEGAL ?
	TTISDO			;GET FUNCTION
	CMP	R0,#037		;FUNCTION VALID ?
	BGT	$DFERR		;FX IS 000 TO 037

	DFXCT			;DF EXECUTE
	BR	.DFX		;RETURN TO CONSOLE

;DIAGNOSTIC FUNCTION WRITE

.DFWRT:	DFLEGAL			;FUNCTION LEGAL ?
	TTISDO			;GET FUNCTION
	CMP	R0,#040
	BLT	$DFERR
	CMP	R0,#077
	BGT	$DFERR		;FW IS 040 TO 077
	MOV	R0,R2		;SAVE FUNCTION
	TTIS36			;GET DATA
	MOV	R0,R1		;PUT ADR OF 36BITS IN R1
	
	MOV	R2,R0		;FUNCTION IN R0
	DFWRT			;DIAGNOSTIC FUNCTION WRITE

.DFX:	JMP	$KONSL

;DIAGNOSTIC FUNCTION SYNC, GENERATES PULSE AT "A36E1"

.FS:	DFLEGAL			;FUNCTION LEGAL ?
	TTITRM
	DFXCTT
	  74			;SYNC IS FUNCTION EXECUTE 74
	BR	.DFX

$DFERR:	PMSG	<?FUNCTION ERR>
	JMP	$CNTLC
;DIAGNOSTIC READ AND PRINT

.DFRD:	DFLEGAL			;FUNCTION LEGAL ?
	CLR	R3
	TTISDO			;GET FUNCTION
	MOV	R0,R2
	TTIBRK
	 BCS	$DFERR
	CMPB	#COMMA,R0	;IF BREAK IS A COMMA, MULTIPLE DFRD
	BNE	1$

	INC	R3
	TTCOCT
	MOV	R0,R4		;SAVE LAST DFRD
1$:	TSTB	RPTFLG
	BNE	2$

	MOV	R2,R0
	PNTOCS
	PSLASH
2$:	MOV	R2,R0
	BEQ	21$		;FR 0 USED TO READ E-BUS
	CMP	R0,#100
	BLT	$DFERR
	CMP	R0,#177
	BGT	$DFERR		;FR IS 100 TO 177
21$:	MOV	#.DFRDA,R1
	DFRDMV
	TSTB	RPTFLG
	BNE	3$
	MOV	R1,R0
	PNT36B			;PRINT IN BINARY

3$:	TST	R3
	BEQ	4$

	PCRLF
	CMP	R2,R4
	BHIS	4$
	INC	R2
	BR	1$

4$:	BR	ALLEXT
.DFDP:	DFLEGAL			;FUNCTION LEGAL ?
	MOV	#.DFRDA,R1
	DFRDMV			;READ THE E-BUS

	TSTB	RPTFLG
	BNE	.DFX
.DFDPC:	MOV	#.DFRDA,R0
	PNT36			;PRINT IT OUT

ALLEXT:	TST	ALLFLG		;DOING ALL ?
	BNE	1$		;YES
	TSTB	RPTFLG		;DOING A REPEAT ?
	BNE	2$		;YES
ALLEX1=.
	PCRLF
2$:	BR	.DFX
1$:	RTS	PC		;ALL, CONTINUE

.MQ:	TTITRM
$ALLMQ=.
	PMSGR	<MQ />
1$:	MOV	#DPMQ,R0
	BR	.DFDP

.FM:	DFLEGAL			;FUNCTION LEGAL ?
	TTITRM
$ALLFM=.
	TSTB	RPTFLG
	BNE	1$
	PNTCI
	"FM
	DFRDT			;READ FM ADDRESS
	  DPFMA
	MOV	@.DAT2,R0
	SHIFTR
	  5
	BIC	#177760,R0
	PNTODT
	  2
	PNTCI
	'/
1$:	MOV	#DPFM,R0
	BR	.DFDP

$DPERR:	JMP	$DFERR
.AR:	TTICHR
	 BCS	$DPERR
	CMPB	#'X,R0		;IS COMMAND 3 LETTERS ?
	BEQ	1$		;BR IF 3RD LETTER IS X
	TTBTRM
$ALLAR=.
	PMSGR	<AR />
2$:	MOV	#DPAR,R0
	BR	.DFDP		;READ AND PRINT AR

1$:	TTITRM
$ALARX=.
	PMSGR	<ARX/>
3$:	MOV	#DPARX,R0
	BR	.DFDP

.AD:	TTICHR
	 BCS	$DPERR
	CMPB	#'X,R0		;IS COMMAND 3 LETTERS ?
	BEQ	1$		;BR IF 3RD LETTER IS X
	CMPB	#'B,R0
	BEQ	.ADB		;ADB, PRINT ADDRESS BREAK
	TTBTRM
$ALLAD=.
	PMSGR	<AD />
2$:	MOV	#DPAD,R0
	BR	.DFDP		;READ AND PRINT AD

1$:	TTITRM
$ALADX=.
	PMSGR	<ADX/>
3$:	MOV	#DPADX,R0
	BR	.DFDP		;READ AND PRINT ADX
.BR:	TTICHR
	 BCS	$DPERR
	CMPB	#'X,R0		;IS COMMAND 3 LETTERS ?
	BEQ	1$		;BR IF 3RD LETTER IS X
	TTBTRM
$ALLBR=.
	PMSGR	<BR />
2$:	MOV	#DPBR,R0
	BR	.DFDP		;READ AND PRINT BR

1$:	TTITRM
$ALBRX=.
	PMSGR	<BRX/>
3$:	MOV	#DPBRX,R0
	BR	.DFDP		;READ AND PRINT THE BRX

.ERG:	TTICHR
	 BCS	$DPER1
	CMPB	#'G,R0
	BNE	$DPER1
	TTITRM

$ALLEB:	PMSGR	<ERG/>
	MOV	#DPERG,R0
	BR	.DFDP		;READ & PRINT EBUS REGISTER

;MASTER RESET

.MRESET:TTITRM
	MRESET
	BR	.DAX

;DEPOSIT INTO AR

.DA:	DFLEGAL			;FUNCTION LEGAL ?
	TTIS36			;GET 36 BIT AR DATA
	MOV	R0,R1		;ADR OF 36 BITS TO R1
	JSR	R5,WIRAR1	;CALL IR/AR WRITE ROUTINE
.DAX:	JMP	$KONSL
.PC:	TTICHR
	 BCS	$DPER1
	CMPB	#'F,R0
	BEQ	.PCF		;"PCF" COMMAND
	TTBTRM
$ALLPC=.
	PMSG	<PC />
	TST	TENRUN		;PDP-10 PRESENTLY RUNNING ?
	BEQ	1$		;NO, GO AHEAD THEN
	DFXCTT
	  CLRRUN		;CLEAR RUN
	TDELAY			;WAIT FOR HALT LOOP
	DFXCTT
	  STPCLK		;STOP CLOCK

	DFPC			;READ PC

	PUSH	R0
	DFXCTT
	  STRCLK		;START CLOCK
	DFXCTT
	  SETRUN		;SET RUN
	DFXCTT
	  CONBUT		;SET CONTINUE
	POP	R0
	BR	PCVMAP		;GO PRINT

1$:	DFPC

PCVMAP:
	PNTADR
	TST	ALLFLG
	BNE	1$
	JMP	ALLEX1		;RETURN TO CONSOLE
1$:	RTS	PC		;ALL, RETURN TO ROUTINE
.VM:	DFLEGAL			;FUNCTION LEGAL ?
	TTICHR
	 BCS	$DPER1
	CMPB	#'A,R0
	BEQ	1$
	CMPB	#'H,R0
	BEQ	.VMH
	BR	$DPER1
1$:	TTITRM
$ALVMA=.
	PMSG	<VMA/>
	DFVMA
	BR	PCVMAP

$DPER1:	JMP	$DFERR

.VMH:	TTITRM
$ALVMH=.
	PMSG	<VMH/>
	DFVMAH
	BR	PCVMAP

.ADB:	DFLEGAL			;FUNCTION LEGAL ?
	TTITRM
	PMSG	<ADB/>
	DFADB
	BR	PCVMAP
;PCF COMMAND - PRINT PC FLAGS
.PCF:	TTITRM
$ALPCF=.
	TST	TENRUN		;PDP-10 PRESENTLY RUNNING ?
	BEQ	1$		;NO, GO AHEAD THEN
	DFXCTT
	  CLRRUN		;CLEAR RUN
	TDELAY			;WAIT FOR HALT LOOP
	DFXCTT
	  STPCLK		;STOP CLOCK
	JSR	PC,PCF		;READ AND PRINT PC FLAGS
	DFXCTT
	  STRCLK		;START CLOCK
	DFXCTT
	  SETRUN		;SET RUN
	DFXCTT
	  CONBUT		;SET CONTINUE
	BR	2$

1$:	JSR	PC,PCF		;READ AND PRINT PC FLAGS
2$:	TST	ALLFLG
	BNE	3$
	JMP	ALLEX1		;PRINT CRLF AND RETURN TO KONSL

3$:	RTS	PC		;ALL, RETURN TO ROUTINE

PCF:	PMSG	<PCF/ >
	MOV	#PCFTBL,R5
	CLR	R4		;R4 ZERO IF THIS IS FIRST FROB TYPED
1$:	MOVB	(R5)+,R0	;GET DIAG FUNC FOR NEXT BIT
	BEQ	9$		;BR IF END OF TABLE
	DFRD			;GET BIT INTO DTE REG
	MOV	@.DAT1,R2	;BITS 0-3
	MOV	@.DAT2,R1	;BITS 4-19
	.REPT 4
	 ASL R1
	 ROL R2
	.ENDR			;BITS 0-7 (4.9-4.2) RIGHT ALIGNED IN R2
	MOVB	(R5)+,R1	;GET MASK FOR BIT OF INTEREST
	BPL	2$
	COM	R2		;BIT BACKWARDS IN HARDWARE
	NEG	R1
2$:	MOV	(R5)+,R0	;GET POINTER TO BIT NAME STRING
	BIT	R1,R2
	BEQ	3$
	TST	R4		;IF NOT FIRST, PUT A COMMA, SPACE
	BEQ	4$
	PNTCI
	  ", 
4$:	PNTAL			;BIT IS ON, GIVE NAME
	INC	R4
3$:	BR	1$		;LOOP BACK FOR NEXT BIT

9$:	RTS PC

;PC FLAGS TABLE
;FIRST BYTE IS DIAG FCN, SECOND IS MASK FOR BIT (NEGATIVE => BIT COMPLEMENTED)
;SECOND WORD -> ASCIZ BIT NAME			(Negative means more than 177)

.MACRO PCFTE NAME,DFN,MASK
	.LIT $$ZZQ,<.ASCIZ\NAME\>
	.BYTE DFN,MASK
	.WORD $$ZZQ
.ENDM

PCFTBL:	PCFTE OV,131,40
	PCFTE CRY0,131,20
	PCFTE CRY1,131,10
	PCFTE FOV,132,20
	PCFTE FPD,130,2
	PCFTE USER,134,340
	PCFTE IOTUSR,136,4
	PCFTE PUBLIC,135,20
	PCFTE ADB INH,137,40
	PCFTE TRP 2,130,40
	PCFTE TRP 1,130,4
	PCFTE FXU,132,10
	PCFTE DIV,131,2
	0

.FE:	TTITRM
$ALLFE:	PMSGR	<FE/>
	MOV	#DPFE,R4
	BR	FESCP

.SC:	TTITRM
$ALLSC:	PMSGR	<SC/>
	MOV	#DPSC,R4
FESCP:	DFLEGAL			;FUNCTION LEGAL ?
	MOV	R4,R0
	DFRD

	MOV	@.DAT2,R3	;GET LO-ORDER 5 BITS
	SWAB	R3		;FROM 7-11 OF DEXWDS
	BIC	#177740,R3

	MOV	R4,R0
	INC	R0
	DFRD

	MOV	@.DAT2,R0	;GET HI-ORDER 5 BITS
	SHIFTR
	3
	BIC	#176037,R0
	BIS	R3,R0		;COMBINE HI & LO ORDER BITS

	TSTB	RPTFLG
	BNE	1$
	PNTODT
	4
	PSPACE
1$:	JMP	ALLEXT
;PRINT PRIORITY INTERRUPT FUNCTIONS

.PI:	DFLEGAL			;FUNCTION LEGAL ?
	TTITRM
$ALLPI=.
	JSR	PC,$ALPIG	;PRINT PI GENS
	JSR	PC,$ALPIH	;PRINT PI HOLDS
	JSR	PC,$ALPIO	;PRINT PI ON'S
	TST	ALLFLG
	BNE	1$
	PCRLF
	JMP	$KONSL

1$:	RTS	PC		;ALL, RETURN TO ROUTINE

$ALPIG:	PMSG	<PI GEN/>
	DFRDT
	  READ1			;READ PI GENS
				;FR 101, BITS 11-17
$ALPIY:	MOV	@.DAT2,R0
	SHIFTR
	  2

$ALPIX:	BIC	#177600,R0	;DATA IS ONLY 7 BITS
	PNTODT
	  3
	RTS	PC

$ALPIH:	PMSG	< PI HOLD/>
	DFRDT
	  READ0			;READ PI HOLDS
	MOV	@.DAT2,R0	;FR 100, BITS 03-09
	MOV	@.DAT1,R1
	ROR	R1
	ROR	R0
	SHIFTR
	  9.
	BR	$ALPIX

$ALPIO:	PMSG	< PI ON/>
	DFRDT
	  READ0			;READ PI ONS
	BR	$ALPIY		;FR 100, BITS 11-17
;PRINT ALL - C-RAM & REGISTERS

.ALL:	TTICHR
	 BCS	1$
	CMPB	#'L,R0
	BNE	1$
	TTITRM
	DFLEGAL			;FUNCTION LEGAL ?
	PNTCPU
	JMP	$KONSL
1$:	JMP	$DFERR		;ERROR

$PNTCPU:SETFLG
	  ALLFLG		;SET ALL FLAG
	PUSH	RPTFLG
	CLR	RPTFLG

	JSR	PC,$ALLEC	;PRINT C-RAM

	JSR	PC,$ALLAR	;PRINT AR
	JSR	PC,$ALLBR	;PRINT BR
	JSR	PC,$ALLAD	;PRINT ADDER
	JSR	PC,$ALLSC	;PRINT SC
	JSR	PC,$ALLPC	;PRINT PC
	PCRLF

	JSR	PC,$ALARX	;PRINT ARX
	JSR	PC,$ALBRX	;PRINT BRX
	JSR	PC,$ALADX	;PRINT ADX
	JSR	PC,$ALLFE	;PRINT FE
	JSR	PC,$ALVMA	;PRINT VMA
	PCRLF

	JSR	PC,$ALLMQ	;PRINT MQ
	JSR	PC,$ALLFM	;PRINT FM
	JSR	PC,$ALLEB	;PRINT EBUS REGISTER
	JSR	PC,$ALVMH	;PRINT VMA HELD
	PCRLF

	JSR	PC,$ALPIG	;PRINT PI GENS
	JSR	PC,$ALPIH	;PRINT PI HOLDS
	JSR	PC,$ALPIO	;PRINT PI ON'S
	POP	RPTFLG
	PCRLF
	CLR	ALLFLG
	EXIT
.SBTTL	PDP-10 START/STOP FUNCTIONS

;THESE REQUIRE STANDARD MICROCODE TO DO ANYTHING WORTHWHILE!

;STOP PDP-10, CLEAR RUN FLOP

$SP:	TTITRM
	TENSP			;STOP TEN
	BCC	1$
	JMP	.XCTER		;DID NOT STOP PROPERLY
1$:	CLR	PRGRUN
	PMSG	<\KL10 STOPPED >
	JSR	PC,$ALSTA	;PRINT PC,VMA,PI,PCF AND A CRLF
	BR	$RNX		;HOPE ENOUGH DELAY BUILT IN

;CONTINUE PDP-10 FROM OLD PC. ASSUME CLOCK MAY BE OFF

$RN:	TTITRM

$RNN:	CLR	CLKPE		;CLEAR CLOCK PARITY ENABLES
	MOV	#20,R2
	MOV	PEBITS,R1	;GET ENABLE BITS
	BEQ	2$		;NOT ENABLED
	BIT	R2,R1		;AR/ARX PARITY ENABLED ?
	BEQ	1$		;NO
	BIS	#2,CLKPE	;YES, SET ENABLE BIT
1$:	BIS	#1,CLKPE	;SET CLOCK STOP ENABLE

2$:	DFWRTT
	  CLKPE
	  LDCHK2		;LOAD ENABLE FUNCTION REGISTER

3$:	BIC	R2,R1
	MOV	R1,CLKPE	;SETUP FM,CRAM,DRAM, FS
	DFWRTT
	  CLKPE
	  LDCHK1		;LOAD CONDITION ENABLE REGISTER

	DFXCTT			;GET CLOCK RUNNING
	  STRCLK
	DFXCTT			;SET RUN AND LET 'ER GO
	  SETRUN
	DFXCTT			;SET CONTINUE BUTTON
	  CONBUT
	SETFLG
	  TENRUN		;SET TEN RUN FLAG
	SETFLG
	  PRGRUN		;SET PROGRAM RUNNING FLAG
$RNX:	JMP	$KONSL
;START PDP-10 DDT

$DDTX:	TTISDL
	 BCS	1$		;NON-NUMBER
	JMP	$DD		;NUMBER, MUST BE FOR D-RAM

1$:	CMPB	#'T,R0
	BEQ	2$		;"DDT", START PDP-10 AT "DDTSRT"
	JMP	$DFERR

2$:	TTITRM
	DFLEGAL			;DON'T DO THIS IF ALREADY RUNNING
	MOV	TDDT,$$STJRS	;SETUP JRST INSTRUCTION
	MOVB	TDDT+2,$$STJRS+2
;CAN'T ENTER DDT WHILE IN USER MODE.
	DFRDT
	 134
	BIT	#2,@.DAT1
	BNE	3$		;BRANCH IF IN EXEC MODE
	PMSG	<?Can't. KL10 in USER mode.>
	JMP	$CNTLC

3$:	CLR 	TENTTY
	MOV	#$$STJRS,R0
	EXCT			;EXECUTE JRST TO START DDT
	BCC	$RNN		;GO SAY -10 IS RUNNING
$DDTER:	JMP	.XCTER		;OR BARF IF MICRO CODE IS HUNG

;SINGLE INSTRUCT PDP-10. ASSUME CLOCK IS RUNNING AND RUN IS SET

$SI:	TENSP			;STOP TEN
	BCS	$DDTER		;DID NOT STOP PROPERLY
	CLR	R5
	TTISDL
	 BCS	4$		;NON-NUMBER
	TTIDEC
	 BCS	2$		;NO ARG, DO ONCE
	MOV	R0,R5
2$:	DFXCTT			;PRESS CONTINUE PULSER
	  CONBUT
	TDELAY			;SMALL TIME DELAY
	DEC	R5		;COMPLETED REQUESTED INSTRUCTIONS ?
	BGT	2$
	JMP	$KONSL		;YES, RETURN TO CONSOLE

4$:	CMPB	#'P,R0
	BNE	2$

5$:	TTITRM			;"SIP",SINGLE INSTRUCT AND PRINT
	DFXCTT			;STOP CLOCK
	  STPCLK
	JMP	SIPNT		;REST SAME AS LAST OF "EXP"

;DIAGNOSTIC FUNCTION LEGALITY CHECK

$DFLEGAL:TST	TENRUN		;PDP-10 PRESENTLY RUNNING ?
	BNE	1$		;YES, OPERATION ILLEGAL, ABORT
	EXIT
1$:	PMSG	<?KL10 RUNNING, TYPE "SP" FIRST>
	JMP	$$$CC
;PULSE THE E-BOX CLOCK

.PL:	DFLEGAL			;FUNCTION LEGAL ?
	CLR	TENCLK		;TURN OFF CLOCK IF ON
	TTISDL
	 BCS	1$		;NO ARG, DO ONCE
	TTIDEC
	 BCS	1$		;DO ONCE ANYWAY
	MOV	R0,R1		;SAVE PULSE COUNT
	BR	2$
1$:	CLR	R1
2$:	ECLOK
	 BCC	3$
	JSR	R1,$ECTIM
3$:	DEC	R1		;DONE REQUESTED CLOCKS ?
	BGT	2$		;NOT YET
.PLX:	JMP	$KONSL

;START MICROCODE IDLE.
;SUPPORT EXAMINE, DEPOSIT, AND EXECUTE OPERATIONS.

.SM:	TTITRM
	SM			;DO THE EMT
	BCS	.XCTER
	BR	.PLX

;CACHE INVALIDATE

.CI:	MOV	#$$CI,R0

.CIF:	TTITRM
	DFLEGAL			;FUNCTION LEGAL ?
	EXCT
	 BCS	.XCTER		;FAILED
	BR	.PLX		;OK, RETURN TO CONSOLE

;CACHE FLUSH

.CF:	MOV	#$$CF,R0
	BR	.CIF

$$CI:	IO10	DATAI,CCA,,0	;INVALIDATE WITHOUT CORE UPDATE
$$CF:	IO10	BLKO,CCA,,0	;SWEEP CACHE, VALIDATING CORE
.EVEN
;EXECUTE A PDP10 INSTRUCTION.

.XCT:	TENSP			;STOP TEN
	BCS	.XCTER		;DID NOT STOP PROPERLY

	TTISDL
	 BCS	1$		;NON-NUMBER

	TTIS36

	EXCT
	 BCS	.XCTER

	BR	.XCT2

1$:	CMPB	#'P,R0		;"EXP" = EXECUTE & PRINT
	BNE	.XCT1

	TTIS36

	LODAR			;LOAD INTO AR
	 BCS	.XCTER

SIPNT=.
	PNORML
	DFXCTT			;SET CONTINUE BUTTON
	  CONBUT

2$:	ECLOK			;CLOCK TO GET STARTED
	 BCC	3$
	JSR	R1,$ECTIM

3$:	BIT	#HALTLP,@.DIAG1
	BNE	2$		;TILL WE LEAVE HALT LOOP
	PNTCPU			;PRINT C-RAM & REGISTERS

4$:	ECLOK			;CLOCK
	 BCC	5$
	JSR	R1,$ECTIM

5$:	PNTCPU			;& PRINT TILL BACK TO HALT LOOP

	BIT	#HALTLP,@.DIAG1
	BEQ	4$

.XCT2:	JMP	$KONSL

.XCT1:	CMPB	#'T,R0		;"EXT" = EXECUTE & TRACE SETUP
	BNE	.CNSER

	TTIS36

	LODAR			;LOAD INTO AR
	 BCS	.XCTER

	DFXCTT			;SET CONTINUE BUTTON
	  CONBUT

	BR	.XCT2

.XCTER:	PMSG	<?UCODE HUNG>
	JMP	$CNTLC

.CNSER:	JMP	$DFERR

;BURST THE KL10 CLOCK

.BU:	DFLEGAL			;FUNCTION LEGAL ?
	CLR	TENCLK		;TURN OFF CLOCKK IF ON
	TTISDL
	BCS	2$		;NO ARG, DO ONCE
	TTIDEC
	BCS	2$		;DO ONCE ANYWAY
1$:	BURST			;PERFORM BURST
	BR	.XCT2
2$:	MOV	#1,R0		;DO ONE BURST
	BR	1$
;SELECT CLOCK SOURCE

.CS:	TTISDL
	BCC	1$
	MOV	CLKDFL,R0
	SR	R0,2
.CSR=.
	BIC	#177774,R0
	PNTNBR
	PCRLF
	JMP	$CONSL

1$:	TTISDO
	CMP	R0,#2
	BGT	.CSRER

	SHIFTL
	2
	BIC	#14,CLKDFL	;CLEAR OLD SOURCE
.CCMN1:	BIS	R0,CLKDFL	;SET NEW SOURCE
.CCMN:	DFLEGAL			;FUNCTION LEGAL ?
	TST	TENRUN
	BEQ	1$
	TENSP			;STOP TEN
	BCS	.XCTER		;DID NOT STOP PROPERLY
1$:	DFWRTT			;WRITE TO CLOCK
	CLKDFL
	LDSEL
	JMP	$KONSL

.CSRER:	JMP	$PARA

;SELECT CLOCK RATE

.CR:	TTISDL
	BCC	1$
	MOV	CLKDFL,R0
	BR	.CSR

1$:	TTISDO
	CMP	R0,#3
	BGT	.CSRER

	BIC	#3,CLKDFL	;CLEAR OLD RATE
	BR	.CCMN1
;PROCESSOR PARITY DISABLE

.PD:	TTITRM
	CLR	PEBITS		;CLEAR PARITY ENABLE BITS
	JMP	$CONSL

;PARITY ENABLED AND CLOCK ERROR STOP MESSAGES

$PEAR:	.ASCIZ	%, AR/ARX%
$PEFM:	.ASCIZ	%, FM PARITY%
$PECR:	.ASCIZ	%, CRAM PARITY%
$PEDR:	.ASCIZ	%, DRAM PARITY%
$PEFS:	.ASCIZ	%, FS PROBE%
.EVEN
;PROCESSOR PARITY ENABLE

;PARITY ENABLE BITS ARE CODED AS FOLLOWS:
; 	AR/ARX, FM, CRAM, DRAM, FS
;	0 = PARITY DISABLED
;	37 WOULD = ALL ENABLED

.PE:	TTISDL
	 BCC	1$

20$:	PMSG	<ENABLED: >
	MOV	PEBITS,R1	;PRINT PARITY ENABLE BITS
	MOV	R1,R0
	PNTODT
	  2
10$:	BIT	#20,R1
	BEQ	11$
	$PMSG
	  $PEAR			;AR/ARX PAGE FAIL
11$:	BIT	#10,R1
	BEQ	12$
	$PMSG
	  $PEFM			;FM PARITY
12$:	BIT	#4,R1
	BEQ	13$
	$PMSG
	  $PECR			;CRAM PARITY
13$:	BIT	#2,R1
	BEQ	14$
	$PMSG
	  $PEDR			;DRAM PARITY
14$:	BIT	#1,R1
	BEQ	15$
	$PMSG
	  $PEFS			;FS PROBE
15$:	PCRLF
3$:	JMP	$CONSL

1$:	TTISDO
	CMP	R0,#37
	BGT	.CSRER
	MOV	R0,PEBITS	;SAVE
	BR	20$
;MICRO-CODE SYNC MARK ROUTINES

.MU:	MOV	#-1,R5		;MICRO UNMARK
	BR	.MMC

.MM:	CLR	R5		;MICRO MARK

.MMC:	DFLEGAL			;FUNCTION LEGAL ?
	TTICRA			;GET C-RAM ADDRESS
	MOV	R0,$ECADR

	RCRAM			;READ C-RAM

	TST	R5
	BNE	3$
	BIS	#20,4(R0)	;SET MARK BIT
	BR	.MMX
3$:	BIC	#20,4(R0)	;CLEAR MARK BIT

.MMX:	MOV	R0,R1
	MOV	$ECADR,R0
	WCRAM			;WRITE C-RAM BACK
	JMP	$KONSL
;MICRO-CODE TIME FIELD CHANGE ROUTINE

.MT:	DFLEGAL			;FUNCTION LEGAL ?
	TTICRA
	MOV	R0,$ECADR

	TTISDO
	CMP	R0,#3		;TIME FIELD IS 0-3
	BGT	.CSRER
	MOV	R0,R5

	MOV	$ECADR,R0
	RCRAM			;READ C-RAM
	BIC	#12,(R0)	;CLEAR OLD TIME
	CLR	R4
	BIT	#2,R5
	BEQ	1$
	BIS	#10,R4
1$:	BIT	#1,R5
	BEQ	2$
	BIS	#2,R4
2$:	BIS	R4,(R0)		;SET NEW TIME
	BR	.MMX
;CACHE ENABLE

;CACHE ENABLE BITS ARE CODED AS FOLLOWS:
;	10 = CACHE 0
;	 4 = CACHE 1
;	 2 = CACHE 2
;	 1 = CACHE 3
;	17 SIGNIFIES ALL CACHES ENABLED

.CE:	TTISDL			;GET ENABLE CODE
	BCS	20$		;CR, PRINT ENABLE
1$:	TTISDO
	CMP	R0,#17		;ENABLE IS 0 TO 17
	BGT	2$
	MOV	R0,CLKDFL+4	;PUT IN CLOCK DEFAULT PARAMETER WORD
	BR	20$
2$:	JMP	$PARAM

20$:	PMSG	<CACHES ENABLED: >
	MOV	CLKDFL+4,R1
	MOV	R1,R0
	PNTODT			;PRINT CODE
	  2
21$:	CLR	R2
	BIT	#10,R1		;CACHE 0 ENABLED ?
	BEQ	22$
	JSR	PC,.CEP

22$:	INC	R2
	BIT	#4,R1		;CACHE 1 ENABLED ?
	BEQ	23$
	JSR	PC,.CEP

23$:	INC	R2
	BIT	#2,R1		;CACHE 2 ENABLED ?
	BEQ	24$
	JSR	PC,.CEP

24$:	INC	R2
	BIT	#1,R1		;CACHE 3 ENABLED ?
	BEQ	25$
	JSR	PC,.CEP

25$:	PCRLF
	JMP	$CONSL

.CEP:	PMSG	<, CACHE >
	MOV	R2,R0
	PNTNBR			;PRINT CACHE ENABLE DIGIT
	RTS	PC
;AC BLOCK SELECTION
;SETS UP "PAGDFL" WORD USED BY "DATAO PAG,0"
;DURING "STD,STM,STL & DDT" START COMMANDS
;SAME "PAGDFL" WORD USED BY "DATAO PAG,20"
;DURING AC BLOCK SELECTION COMMAND

.AC:	DFLEGAL
	MOV	#PAGDFL+2,R5
	TTISDL			;ALLOW FOR "ACBLK" OR "AC BLK"
	 BCC	5$		;NUMBER
	CMPB	#'B,R0
	BNE	5$
	TTICHR
	CMPB	#'L,R0
	BNE	5$
	TTICHR
	CMPB	#'K,R0
	BNE	5$

	TTISDL			;ANY NUMBER ?
	 BCS	4$		;NO, PRINT PRESENT SELECTION

	TTISDO			;GET SELECTION DIGIT
	CMP	R0,#7		;MUST BE 0 TO 7
	BGT	5$
	BEQ	3$		;IF BLK #7, GIVE UCODE WARNING

1$:	PUSH	R0
	PMSG	<PREV AC BLK >
	MOV	(R5),R0
	SHIFTR
	  11.
	PNTNBR
	PNTCI
	", 
	POP	R0
	SHIFTL			;PLACE SELECTION DIGIT IN BITS 6-8
	  11.
	BIC	#034000,(R5)
	BIS	R0,(R5)		;INSERT IN PAGE DEFAULT WORD
4$:	PMSG	<SELECTED AC BLK >
	MOV	(R5),R0		;PRINT PRESENT AC BLOCK SELECTION
	SHIFTR
	  11.
	PNTNBR
	PCRLF
	EXAMT			;SAVE MEM LOCATION 20
	  20
	  $SAV20
	BCS	6$
	DPOSVT			;PUT DATAO PAG ARGUMENT IN 20
	  20
	  PAGDFL
	BCS	6$
	MOV	#DATPAG,R0
	EXCT			;EXECUTE DATAO PAG
	 BCS	6$
	DPOSVT			;RESTORE 20
	  20
	  $SAV20
	BCS	6$
	JMP	$CONSL

3$:	PUSH	R0
	PMSG	<UCODE BLK\>
	POP	R0
	BR	1$

6$:	PMSG	<?SELECTION ERR>
	JMP	$CNTLC

5$:	JMP	$PARAM		;ERROR

DATPAG:	IO10	DATAO,PAG,,20	;SELECT AC BLOCK
.EVEN
;START PDP10 AT ADDRESS SPECIFIED AS LOWER 18 BITS OF 36-BIT ARGUMENT.

$ST:	DFLEGAL			;PDP-10 MUST BE STOPPED BEFORE YOU CAN START IT
	TTISDL
	 BCS	4$		;NON-NUMBER
	TTIS36
$$ST=.
	CLR	R5
5$:	MOV	#$$STJRS,R1
	MOVB	(R0)+,(R1)+
	MOVB	(R0)+,(R1)+
	BICB	#3,(R1)		;CLEAR BITS 18-19
	BISB	(R0),(R1)	;SET LAST TWO BITS

3$:	TST	R5		;ADDRESS START?
	BEQ	11$		;YES. DO JUST A JRST
	SM			;START MACHINE.  RESET MACHINE
	 BCS	$STERR
	DPOSVT			;DEPOSIT "DATAO PAG,0" ARGUMENT
	  0			;IN AC0, SELECTS CURRENT AC USAGE
	  PAGDFL
	 BCS	$STERR
	SETFLG			;SET TEN RUN FLAG
	  TENRUN
.IIF DF SAILVR,	CLR	SWTDEP	;DISABLE AUTO-DEPOSIT!
	TENSW			;DEPOSIT PDP-10 SWITCHES
	 BCC	32$
	JMP	C10SWE		;SWITCH ERROR
32$:	MOV	#4.,R1
	MOV	#$STTB1,R0
1$:	PUSH	R0
	EXCT			;EXECUTE A TEN INSTR
	 BCS	$STERR
	POP	R0
	ADD	#5,R0
	DEC	R1
	BNE	1$		;DO ANOTHER
	JSR	PC,$TI36C	;ZERO SELECTED AC BLOCK
	MOV	#$DRAM,R1
	MOV	#16.,R0		;FROM AC0 TO AC17
	D10ZRO			;NECESSARY FOR FM PARITY
	 BCS	$STERR
11$:	MOV	#$$STJRS,R0
	EXCT			;EXECUTE JRST TO START ADR
	 BCS	$STERR
	CLR	TENTTY		;TURN OFF "TENCHR" ROUTINE
	JSR	PC,$CMCLR	;CLEAR COMMON STORAGE
	MOV	#100.,$ENDCT	;REPORT EOP EVERY 100
	JMP	$RNN

4$:	CMPB	#'D,R0		;IF "STD", START 10 DIAGNOSTIC
	BNE	6$
	MOV	#TDIAG,R0
7$:	TTITRM
$$$ST=.
	MOV	#-1,R5
	BR	5$

6$:	CMPB	#'L,R0		;IF "STL", START PDP-10 LOADER
	BNE	8$
	MOV	#TLDR,R0
	BR	7$

8$:	CMPB	#'M,R0		;IF "STM", START PDP-10 MONITOR
	BNE	.CNERR		;IF NONE, ERROR (DON'T START AT THE LAST START ADDR)
	MOV	#TMON,R0
	BR	7$

$STERR:	JMP	.XCTER

	HRRI=541
	HRLZI=515
	JRST=254
	DTE=200

$STTB1:	IO10	CONO,APR,,267760	;RESET APR
	IO10	CONO,PI,,10000		;PI SYSTEM CLEAR
	IO10	CONO,PAG,,0		;PAGING SYSTEM CLEAR
	IO10	DATAO,PAG,,0		;USER BASE CLEAR & AC SELECT
.EVEN
.CNERR:	JMP	$PARA
.SBTTL	PDP-10 DEPOSIT AND EXAMINE CONSOLE FUNCTIONS

.DP:	MOV	#.DPXAD,R5
	TTISDL
	 BCS	.DPS
	TTIS36
	MOV	(R0)+,(R5)+	;LOW ADDRESS
	MOV	(R0),(R5)	;HIGH ADDRESS
.DPNX1:	TST	-(R5)

.DPCOM:	TTIS36			;GET DATA
	MOV	R5,R1		;PTR TO ADR
	JSR	PC,$TENRN
	DPOS			;DO IT
	 BCS	.DPCM1
$VBX:	JMP	$KONSL

.DPCM1:	PMSG	<?DM>
	JSR	R1,$DFTM1

.DPNX:	MOV	#.DPXAD,R5
	ADD	#1,(R5)+	;BUMP LOW
	ADC	(R5)		;CARRY TO HIGH
	BR	.DPNX1

.DPS:	BVS	.DPCOM		;COLON, USE PRESENT ADDRESS
	BR	.CNERR

$TENRN:	BIT	#ERRSTP,@.DIAG1	;TEN CLOCK RUNNING ?
	BEQ	1$		;YES, OK
	JMP	TENCERR		;NO, REPORT IT
1$:	RTS	PC

$VB:	TTITRM
	TST VRBFLG
	BEQ $VB1
	CLR VRBFLG
	PMSG <CONCISE TYPEOUT
>
	BR $VBX

$VB1:	SETFLG
	 VRBFLG
	PMSG <VERBOSE TYPEOUT
>
	BR $VBX

$KA:	TTITRM
	JSR PC,KASET		;ENABLE KASIM
	BR $VBX
;MEMORY ZERO
;  "MZ ADR,COUNT"

.MZ:	DFLEGAL 		;FUNCTION LEGAL ?
	TTIS36 			;INPUT PDP-10 START ADDRESS
	MOV	$DRAM,MMDAT	;SAVE IT
	MOV	$DRAM+2,MMDAT+2
	MOV	#MMDAT,R1	;POINTER FOR D10ZRO
	TTIS36			;INPUT NUMBER OF PDP-10 WORDS
	 BCS	1$
	MOV	$DRAM+2,R2	;PICK UP NUMBER OF 64K MOBIES
	BEQ	2$
	BPL	4$
	MOV	#XMEMSZ/64.,R2	;MZ 0,-1.  DON'T TRY TO CLEAR
	CLR	$DRAM		; 4096 MILLION WORDS.
4$:	CLR	R0		;CLEAR ONE SMALL MOBY
	D10ZRO
	 BCS	3$
	JSR	PC,$TIRDY	;ALLOW ↑C IN THIS SLOW LOOP
	BCS	69$
	CMPB	$TICHR,#CNTRLC
	BNE	69$
	JMP	$TICC		;↑C, ABORT

69$:	INC	MMDAT+2		;BUMP ADDRESS
	DEC	R2
	BGT	4$
2$:	MOV	$DRAM,R0	;CLEAR FINAL FRACTIONAL MOBY
	BEQ	5$		;EXACT MULTIPLE OF 64K
	D10ZRO 			;ZERO MEMORY
	 BCS	3$

5$:	JMP	$KONSL

1$:	MOV	#1,$DRAM	;NO COUNT SPECIFIED
	BR	2$		;SO CLEAR ONE WORD

3$:	PMSG	<?MZ>
	JSR	R1,$DFTM1
	JMP	$RUNLP
.EXM:	MOV	#.DPXAD,R5
	CLR	R3
	TTISDL
	 BCS	.EXMSP		;NON-NUMBER
	TTIS36			;GET PDP-10 ADDRESS
	MOV	(R0)+,(R5)+	;SAVE LOW 16 BITS
	MOV	(R0),(R5)	;SAVE HIGH BITS
	TST	-(R5)
	TTIBRK			;GET BREAK
	 BCS	.CNERR
	CMPB	#',,R0
	BNE	.EXCOM
	COM	R3		;COMMA, MULTIPLE PRINT
	PNORML
	TTIS36			;GET ENDING ADDRESS
	MOV	(R0),R4		;SAVE LOW 16 BITS

.EXCOM:	MOV	R5,R0
	JSR	PC,$TENRN
	EXAM
	 BCS	3$
5$:	TSTB	RPTFLG
	BNE	1$
	MOV	R5,R0
	PNTADR
	PNTBAK			;BACKUP POINTER TO WIPE OUT SPACE
	PSLASH
	MOV	#$DRAM,R0
	PNT36
	TST	R3		;DOING MULTIPLE PRINT ?
	BEQ	2$
	PCRLF
	CMP	(R5),R4
	BEQ	2$
	INC	(R5)		;INCREMENT LOW 16 BITS, 64K
	BR	.EXCOM		;DO NEXT ADDRESS
2$:	PCRLF
1$:	JMP	$KONSL

3$:	BMI	4$
	PMSG	<?EM>
	JSR	R1,$DFTM1

4$:	$PMSGR
	  $EBPAR		;E-BUS PARITY ERROR
	BR	5$

.EXMSP:	BVS	.EXMNX		;COLON OR SLASH, EXAMINE NEXT
	BNE	.EXCOM		;NONE, EXAMINE SAME
	SUB	#1,(R5)+	;UPARROW, EXAMINE PREVIOUS
	SBC	(R5)
	BR	.EXMN1
.EXMNX:	MOV	#.DPXAD,R5
	ADD	#1,(R5)+
	ADC	(R5)
.EXMN1:	INC	$INPTC
	CLR	R3
	TST	-(R5)
	BR	.EXCOM
.SBTTL	CONSOLE IDLE RUN LOOP

;PROVIDES PDP-10 SUPPORT WHEN "TENRUN" SET
;AND ADDITIONALY PDP-10 MONITOR SUPPORT IF "MONMODE" SET

$RUNLP:	TSTB	TENRUN			;PDP-10 RUN TIME SUPPORT ?
	BNE	1$			;JUMP IF YES
	JMP	$TTILIN			;NO, CONSOLE COMMAND INPUT

1$:	CLR	DDTTM2			;SETUP DDT MODE TIMEOUT
2$:	BIT	#KLRUN,@.DIAG1		;IS THE KL10 RUNNING?
	BNE	3$			;YES.
	JMP	TENDEAD			;PDP-10 HALTED

3$:	BIT	#ERRSTP,@.DIAG1		;PDP-10 CLOCK ERROR STOP ?
	BEQ	31$			;NO.
	JMP	TENCERR			;YES, REPORT.

31$:	JSR	PC,C10COP		;PERFORM CLOCK OPERATIONS
.LIF DF %%QMP
	JSR	PC,SND10		;CHECK FOR QUEUED MESSAGE FOR 10

.LIF NDF %%QMP
	BIT	#TO11DB,@.STDTE		;IS PDP-10 REQUESTING SERVICE?

.LIF DF %%QMP
	TST	T11DBF			;IS PDP-10 REQUESTING SERVICE?

	BNE	TENCMD			;YES.

5$:	TST	MONMODE			;MONITOR SUPPORT MODE ?
	BEQ	20$			;NO

6$:	JSR	PC,$TIRDY		;TTY INPUT FLAG SET ?
	BCC	MTTYIN			;YES, SEND CHAR TO 10

7$:	TST	MTTYOF			;TTY OUTPUT IN PROGRESS ?
	BEQ	2$			;NO

8$:	JSR	PC,$TORDY		;TTY OUTPUT COMPLETED ?
	BCC	MTTYOC			;YES, NOTIFY 10
	BR	2$			;STAY IN MONITOR LOOP

20$:	TST	DDTFLG			;PDP-10 DDT INPUT MODE ?
	BEQ	21$			;NO
23$:	DEC	DDTTM2			;WAITED LONG ENOUGH ?
	BNE	2$			;NOT YET
	CLR	DDTFLG			;YES, REVERT TO CONSOLE MODE

21$:	JSR	PC,$TIRDY	;ANY TTY INPUT YET ?
	BCS	2$		;NO, STAY IN RUN LOOP
	JMP	$TILRN		;YES, GO INPUT
;MONITOR TELETYPE CHARACTER INPUT -- MTTYIN MTTYI0 MTTYI1 C10DN1 MTTYER MTTYOC MTTYO MTTYP MTTYX MTTYC MTTYCF $MC MTTYS C10DN2

MTTYIN:	MOVB	$TICHR,R0	;GET INPUT CHAR
	CMPB	R0,#MSWCHR	;MONITOR TO "KLDCP" SWITCH CHAR ?
	BNE	MTTYI1		;JUMP IF NOT.
MTTYI0:	PMSG	<\KLDCP\. ←>
	JMP	$TTILIN		;READ ONE KLDCP COMMAND, REVERT TO RUN LOOP

MTTYI1:	MOV	R0,TENDAT
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	DPOSVT			;SEND CHAR TO TEN
	  $DTF11
	  TENDAT
	 BCS	MTTYER		;FAILED
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	D10MON			;SET -1 TO 10 TTY INPUT FLAG
	  $DTMTI
	 BCS	MTTYER

C10DN1:	TST KASIM
	BNE $RUNLP		;AVOID DINGING 10 IF KASIM
C10DN2:	MOV #INT10S,@.STDTE	;DING TEN
	BR $RUNLP

MTTYER:	JMP	C10TIE

;MONITOR TELETYPE OUTPUT COMPLETE

MTTYOC:
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	D10MON			;SET -1 TO 10 TTY OUTPUT DONE FLAG
	  $DTMTD
	 BCS	MTTYER
	CLR	MTTYOF		;CLEAR OUTPUT IN PROGRESS
	BR	C10DN1

;MONITOR TELETYPE OUTPUT ROUTINE

MTTYO:	MOV	R5,R0		;GET OUTPUT CHAR
	BIC	#177400,R0	;STRIP TO 8 BITS, 10 DOES PARITY
	MOVB	R0,$TOCHR	;PRINT CHAR
	JSR	PC,$TOOUT
MTTYP:	SETFLG
	  MTTYOF		;SET OUTPUT IN PROGRESS FLAG
MTTYX:	BR	C10DON		;ALLOW 10 TO CONTINUE

;MONITOR MODE CONTROL

MTTYC:	SETFLG			;SET MONITOR MODE.
	  MONMODE
	BR	MTTYP		;SET OUTPUT IN PROGRESS, EVEN IF IT'S NOT.

MTTYCF:	CLR	MONMODE		;CLEAR
	BR	MTTYX

$MC:	SETFLG			;CONSOLE MONITOR CONTINUE
	  MONMODE
	SETFLG
	  TENRUN		;ONLY WAY TO GET BACK FROM CONTROL C
	SETFLG
	  PRGRUN
	SETFLG
	  MTTYOF		;SET OUTPUT IN PROGRESS FLAG (even if not true)
	BR	$$TDX

MTTYS:	MOV	MONMODE,R0	;SEND 10 MONITOR TTY STATE
	JMP	C10TIX
.SBTTL	PDP-10 RUN TIME SUPPORT		;TENCMD CMD10T C10DON

TENCMD:
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	EXAMT			;GET COMMAND CODE
	  $DTCMD
	  $ECMD
	BCC	1$
	BPL	2$		;EXAMINE FAILED
	$PMSG
	  $EBPAR		;E-BUS PARITY ERROR
2$:	BR	C10DNX

1$:	MOV	$ECMD,R5
	MOV	R5,R1
	SWAB	R1
	BIC	#177760,R1
	SL	R1,1
	JMP	@CMD10T(R1)	;DISPATCH TO ROUTINE

CMD10T:	C10TO		;TTY OUT
	C10PRG		;PROGRAM CONTROL
	C10CLK		;CLOCK
	C10SW		;SWITCHES
	C10TO		;TTY OUT
	C10TI		;TTY IN
	C10PNT		;PRINT CONTROL
	C10DDT		;DDT INPUT MODE
	MTTYO		;MONITOR TTY OUTPUT
	MTTYC		;MONITOR TTY MODE CONTROL ON
	MTTYCF		;MONITOR TTY MODE CONTROL OFF
	MTTYS		;MONITOR TTY STATE
	QMPCMD		;14 COMMAND FOR QMP (TO11 ITEM COUNT)
	C10DNX		;15-17 UNUSED NOW
	C10DNX
	C10DNX

C10DON:
.IIF NDF %%QMP,	MOV #INT11C,@.STDTE	;CLEAR DONG
.IIF DF %%QMP,	CLR T11DBF		;CLEAR SOFTWARE DONG
.IIF NE EPTREL,	MOV #XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	D10MON		;SET -1 TO 10 "$DTFLG"
	  $DTFLG	;DTE20 OPERATION COMPLETE FLAG
	 BCS C10DNX	;next page.
	JMP C10DN2	;DONG 10, WAIT FOR NEXT COMMAND

;C10DNX, TENCERR

.IF NDF %%QMP
QMPCMD:			;COMMAND UNDEFINED IF NO QMP
.ENDC

C10DNX:	CLR	TENRUN
	PMSG	<?10 CMD>
	JSR	R1,$DFTM1	;FALLS INTO TENCERR
TENCERR:CLR	TENRUN
	CLR	KLCLKR		;CLEAR TEN RUNNING
	PFORCE
	PMSG	<\KL10 CLOCK ERROR STOP>
	DFRDT
	  106
	BIT	#BIT5,@.DAT3	;FIELD SERVICE ?
	BEQ	1$
	$PMSG	
	  $PEFS			;FS PROBE

1$:	DFRDT
	  105
	BIT	#BIT5,@.DAT3	;FM PARITY ?
	BEQ	2$
	$PMSG	
	  $PEFM			;FM PARITY

2$:	DFRDT
	  104
	BIT	#BIT5,@.DAT3	;CRAM PARITY ?
	BEQ	3$
	$PMSG	
	  $PECR			;CRAM PARITY

3$:	DFRDT
	  103
	BIT	#BIT5,@.DAT3	;DRAM PARITY ?
	BEQ	4$
	$PMSG	
	  $PEDR			;DRAM PARITY
4$:	PNTCPU			;PRINT ALL CPU INFORMATION
	BR	$$TDX

TENDEAD: CLR	TENRUN		;CLEAR TEN RUN FLAG
	PFORCE
	PMSG	<\KL10 HALTED >
	JSR	PC,$ALSTA
$$TDX:	JMP	$CONSL

$ALSTA:	SETFLG			;MAKE COMMAND ROUTINES INTO SUBROUTINES!
	  ALLFLG
	JSR	PC,$ALLPC	;PRINT PC
	JSR	PC,$ALVMA	; AND VMA
	JSR	PC,$ALLPI	; AND PI
	PMSG	< >
	JSR	PC,$ALPCF	; AND PC FLAGS
	PCRLF			;AND CRLF
	CLR	ALLFLG
	RTS	PC

;C10TO, C10TI

C10TO:	SETFLG			;TEN TO ELEVEN FOR TYPEOUT
	  TENTTY		;ALLOW "TENCHR" TO OPERATE
	MOV	#$TNBUF,$TNPTC	;RESET 10 INPUT POINTERS
	MOV	#$TNBUF,$TNPTR
	MOV	R5,R1		;GET ASCII CHAR
	PLDBUF			;PUT IN TTY OUT BUFFER
	BR	C10DON

C10TI:	CLR	DDTFLG		;TTY INPUT TO 10
	CMP	#$OUTBF,$OUTPT	;ANY OUTPUT WAITING ?
	BNE	C10TIZ		;YES
11$:	CMP	$TNPTC,$TNPTR	;CURRENT BUFFER EMPTY ?
	BGE	C10TIZ		;YES

	MOV	$TNPTC,R1	;GET CHAR POINTER
	MOVB	(R1)+,R0	;FETCH CHAR FROM 10 BUFFER
	MOV	R1,$TNPTC

C10TIX:	MOV	R0,TENDAT	;PUT CHAR IN 28-35 OF TEN WORD
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	DPOSVT			;DEPOSIT IN FROM 11 WORD
	  $DTF11
	  TENDAT
	 BCC	C10DON
C10TIE:	PMSG	<?10 TTI>
	BR	$$C1
C10TIZ:	TTILIN			;INPUT LINE FOR TEN
	 BCS	5$		;NO RESPONSE
	MOV	#$TNBUF,R1
3$:	TTICHR			;GET CHAR FROM INPUT
	 BCS	4$		;EMPTY
	MOVB	R0,(R1)+	;PUT IN TEN BUFFER
	BR	3$
4$:	MOV	R1,$TNPTR	;UPDATE 10 EOL POINTER
	MOV	#$TNBUF,$TNPTC	;SET PICKUP POINTER TO START
	BR	C10TI		;GO SEND FIRST CHAR TO TEN
5$:	CLR	R0		;NULL = TIMEOUT
	BR	C10TIX

C10PNT:	MOV	R5,R1		;GET CONTROL BYTE
	BIC	#177400,R1
	MOV	R1,$FORCE	;PUT IN FORCE FLAG
	CLR	DDTFLG		;CLEAR DDT MODE
C10X:	JMP	C10DON
;Switch functions.  C10SW

C10SW:	MOV	R5,R1 		;LOAD SWITCHES INTO FROM 11 WORD
	BIC	#177774,R1	;2 BIT SUBFUNCTION
	SL	R1,1
	JMP	@C10SWT(R1)

C10SWT:	C10SW0			;NORMAL SWITCH READ
	C10SW1			;ENABLE AUTOMATIC DEPOSIT SWITCHES IN 10-MEMORY
	C10SW2			;DISABLE AUTOMATIC DEPOSIT SWITCHES IN 10-MEMORY
	C10SW0			;UNDEFINED.

C10SW1:	SETFLG
	 SWTDEP
	BR	C10SW0

C10SW2:	CLR	SWTDEP		;DON'T AUTO-DEPOSIT
C10SW0:
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	DPOSVT			;LOAD SWITCHES INTO FROM 11 WORD
	  $DTF11
	  SWS10
	 BCS	C10SWE		;BRANCH IF LOSING

	TST	SWTDEP		;DID PDP-10 ASK FOR SWITCHES?
	BEQ	C10X		;NO.  WELL, DON'T STORE UNTIL ASKED.  DONE
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	DPOSVT			;LOAD SWITCHES INTO $DTSWR
	  $DTSWR
	  SWS10
	 BCC	C10X		;BRANCH IF WINNING

C10SWE:	PMSG	<?10 SW>
$$C1:	JMP	$CNTLC

$SW:	MOV	#SWS10,R5
	TTISDL
	 BCS	1$		;NON-NUMBER, TYPE PRESENT
	TTIS36
	MOV	(R0)+,(R5)+	;PUT IN SWITCH WORD
	MOV	(R0),(R5)
2$:	TENSW			;DO PDP-10 SWITCHES
	 BCS	C10SWE		;ERROR
3$:	JMP	$KONSL

1$:	TENSW			;FIRST READ AND STORE CURRENT SWITCHES
	 BCS C10SWE
	PFORCE
	MOV	R5,R0		;PRINT CURRENT SWITCHES
	PNT36
	PCRLF
	BR	3$

C10DDT:	SETFLG
	  DDTFLG		;SET FOR DDT MODE INPUT
	PFORCE			;SET FORCED PRINTOUT
	CMP	#$OUTBF,$OUTPT	;ANY OUTPUT WAITING ?
	BEQ	2$		;NO
	SETFLG
	  $TTLKF		;PREVENT INPUT CHECKS
	PRINTT			;YES, PRINT IT
2$:	TTLOOK			;GET INPUT CHAR
	 BCS	3$		;NOTHING THERE, SEND ZERO
3$:	CMPB	R0,#MSWCHR	;SWITCH TO KLDCP?
	BNE	C10TIX		;NO.
	JMP	MTTYI0		;YES.  READ A LINE FOR KLDCP
;C10PRG C10PT C10P2 C10P1 C10X1 C10P3 C10P4 C10P5 C10KAS KASET

C10PRG:	MOV	R5,R1		;GET CONTROL FIELD
	BIC	#177760,R1
	SL	R1,1
	JMP	@C10PT(R1)	;DISPATCH

C10PT:	TENDEAD		;HALT
	C10P1		;FATAL
	C10P2		;ERROR HALT
	C10P3		;END OF PROGRAM
	C10P4		;END OF PASS
	C10P5		;GIVE PDP-10 CLOCK DEFAULT WORD
	DIASEL		;"DIAMON" FILE SELECTION
	DIARD		;"DIAMON" FILE READ
	P10CMD		;PDP-10 PROGRAM COMMAND
	C10KAS		;TURN ON KA SIMULATION
	C10DNX
	C10DNX
	C10DNX
	C10DNX
	C10DNX
	C10DNX

C10P2:	CLRB	TENRUN
C10P1:	CLR	TENCLK
C10X1:	JMP	C10DON

C10P3:	CLRB	TENRUN		;TURN OFF TEN RUNNING
	ERREOP			;END OF PROGRAM

C10P4:	EOP
	BR	C10X

C10P5:
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	DPOSVT
	  $DTF11
	  CLKDFL
	 BCS C10BCR
	BR C10CX

C10KAS:	JSR PC,KASET	;SET KASIM MODE
	JMP C10DON

KASET:	TST KASIM
	BNE 1$		;KASIM ALREADY ENABLED
	SETFLG
	 KASIM
	SETFLG
	 SWTDEP		;ENABLE AUTO SWITCH DEPOSIT
	SETFLG
	 MONMODE	;TURN ON MONMODE FOR TTY I/O
	SETFLG
	 MTTYOF		;SET TTY OUTPUT DONE FLAG
	SETFLG
	 TENCLK		;ENABLE CLOCK INTERRUPTS AND SETTING DTCLK
1$:	RTS PC

;Clock operations.  C10CLK

C10CLK:	MOV	R5,R1
.IIF EQ SAILVR,	BIC	#177774,R1
.IIF GT SAILVR, BIC	#177770,R1		;3 BITS FOR SAIL
	SL	R1,1
	JMP	@C10CPT(R1)

C10CPT:	C10C0			;DISABLE CLOCK COUNT
	C10C1			;RESET CLOCK COUNT.  ENABLE CLOCK COUNT
	C10C2			;RESET CLOCK. ENABLE CLOCK INT AFTER PERIOD
	C10C3			;READ CLOCK COUNT TO 10.
.IF GT SAILVR
	C10C4			;SET TIME BASE FROM 10. ENABLE KEEPING TIME
	C10C5			;GIVE TIME BASE TO 10.
.IF DF CLKASB
	C10C6			;STORE AND ENABLE STORING TIME IN $DTTIME
	C10CER
.IFF
	C10CER			;ERROR
	C10CER			;ERROR
.ENDC ;CLKASB
.ENDC ;SAILVR

C10C0:	CLR	TENCLK
C10CX:	JMP	C10DON

C10C3:
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	DPOSVT			;LOAD CLOCK COUNT INTO FROM 11 WORD
	  $DTF11
	  CLKCNT
C10BCR:	 BCS	C10CER		;ERROR
	BR	C10CX

C10C1:	SETFLG
	  TENCLK
.IF NDF SAILVR
C10CX1:	BIC	#200,KWLKS
1$:	TSTB	KWLKS		;WAIT FOR CLOCK
	BPL	1$		;THEN CLEAR TO ALLOW FOR
	BIC	#200,KWLKS	;16MS BEFORE 1ST CLOCK
.IFF
C10CX1:	CLR	CLKFLG		;SAIL VERSION.  WAIT FOR CLOCK FLAG TO CHANGE
1$:	TST	CLKFLG
	BEQ	1$		;LOOP UNTIL INTERRUPT SEEN.
.ENDC

	MOV	#CLKCNT,R0	;INIT CLOCK COUNTER
	CLR	(R0)+
	CLR	(R0)+
	CLR	(R0)
	JMP	C10DON


C10C2:
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	EXAMT			;GET WAIT COUNT FROM TO 11 WORD
	  $DTT11
	  C10CW
	 BCS	C10CER
	MOV	#177400,TENCLK
	BR	C10CX1

C10COP:
.IF NDF SAILVR
	TSTB	KWLKS		;CLOCK FLAG SET ?
	BPL	1$		;NO, RETURN
	BIC	#200,KWLKS	;CLEAR FLAG
.IFF
	TST	CLKFLG
	BEQ	1$
	CLR	CLKFLG
.ENDC

	INC	$TTYTIM		;COUNT TTY TIMER
	CMP	SWR,$$SWR	;PDP-11 CONSOLE SWITCHES CHANGED ?
	BEQ	3$		;NO
	PUSH	R0
	TENSW			;YES, DO PDP-10 SWITCHES
	 BCS	C10CER		;ERROR
	POP	R0
3$:	TSTB	TENRUN		;IS 10 RUNNING ?
	BEQ	1$		;NO
.IF DF CLKASB
	TST TMSFLG
	BEQ 4$			;NOT TIME TO STORE TIME
	CLR TMSFLG
	JSR PC,RDCLK		;READ TIME/DATE INTO TIMTMP
.IIF NE EPTREL,	MOV #XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	DPOST			;STORE IN EPT DTTIME
	  $DTTIME
	  TIMTMP
	 BCS C10CER		;ERROR
.ENDC ;DF CLKAB
4$:	TST	TENCLK
	BEQ	1$		;CLOCK NOT ENABLED
	ADD	#1,CLKCNT	;INCREMENT PDP-10 CLOCK COUNT
	ADC	CLKCNT+2
	ADC	CLKCNT+4
	TSTB	TENCLK		;DOING WAIT ?
	BNE	2$		;NO
	CMP	CLKCNT,C10CW	;WAITED LONG ENOUGH ?
	BNE	1$		;NOT YET
2$:	PUSH	<R0,R1>
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	D10MON			;SET -1 TO 10 "$DTCLK"
	  $DTCLK
	 BCS	C10CER
	MOV	#INT10S,@.STDTE	;DING TEN
	POP	<R1,R0>
1$:	RTS	PC

C10CER:	CLR	TENCLK
	PMSG	<?10 CLKOP>
	JMP	$CNTLC


.IFG SAILVR
C10C4:	
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	EXAMT					;GET ADDRESS FROM TO 11 WORD
	  $DTT11
	  TIMADR
	 BCS	C10CER				;CAN'T READ ADDRESS
	MOV	#TIMADR,R0
	BIC	#177774,2(R0)			;CLEAR ALL BUT BITS 18-19 (TIMADR+2)
	MOV	#EXVIRT!PRTOFF,$TADSP		;ADDRESS GIVEN IS EXEC VIRTUAL
	EXAM					;EXAMINE 10.  RESULT TO $DRAM
	 BCS	C10CER				;IF EXAMINE FAILED.
	MOV	$DRAM,R0			;HIGH WORD BITS 20-35
	SL	R0,3				;SHIFT THREE PLACES
	MOV	R0,TIMADR+4			;SAVE HIGH BITS FOR AWHILE
	MOV	#TIMADR,R0
	ADD	#1,(R0)+			;INCREMENT PDP-10 ADDRESS
	ADC	(R0)				;FOR FETCH OF LOW ORDER WORD
	BIC	#177774,(R0)
	TST	-(R0)
	MOV	#EXVIRT!PRTOFF,$TADSP		;ADDRESS GIVEN IS EXEC VIRTUAL
	EXAM	
	 BCS	C10CER
	MOV	#$DRAM+4,R0
	BIC	#177770,(R0)			;CLEAR ALL BUT LOW WORD'S BITS 1-3
	BIS	TIMADR+4,(R0)			;INCLUDE BITS 23-35 OF HIGH WORD
	MOV	#TIMBAS+4,R1
	PUSH	PS
	MOV	#PR7,PS				;TURN OFF INTERRUPTS
	MOV	(R0),(R1)
	MOV	-(R0),-(R1)
	MOV	-(R0),-(R1)
	POP	PS
	SETFLG
	 KTIMBS					;KEEP TIME BASE
C10XXX:	JMP	C10DON


C10C5:	MOV	#TIMTMP,R1
	MOV	#TIMBAS,R0
	PUSH	PS
	MOV	#PR7,PS				;TURN OFF INTERRUPTS
	MOV	(R0)+,(R1)+			;COPY TIMTMP←TIMBAS
	MOV	(R0)+,(R1)+
	MOV	(R0),(R1)
	POP	PS
	TST	KTIMBS				;ARE WE COUNTING TIMEBASE?
	BNE	1$				;JUMP IF YES
	CLR	(R1)				;NO. TIMEBASE NOT KEPT OR INVALID
	CLR	-(R1)				;RETURN ZERO.
	CLR	-(R1)
1$:
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	EXAMT					;GET DEP ADDRESS FROM TO 11 WORD
	  $DTT11
	  TIMADR
	 BCS	C10CER				;CAN'T READ ADDRESS
	MOV	#TIMADR,R1
	BIC	#177774,2(R1)			;CLEAR ALL BUT BITS 18-19 (TIMADR+2)
	MOV	TIMTMP+4,R2			;GET HIGH ORDER TIME BASE
	SR	R2,3				;SHIFT TO ALIGN BITS 23-35
	MOV	#$DRAM+4,R0
	CLR	(R0)
	CLR	-(R0)
	MOV	R2,-(R0)			;$DRAM+0←BITS 23-35 OF HIGH WORD
	MOV	#EXVIRT!PRTOFF,$TADSP		;ADDRESS GIVEN IS EXEC VIRTUAL
	DPOSVR					;SEND HIGH WORD
	 BCS	C10CER
	MOV	#TIMADR,R1			;INCREMENT ADDRESS TO LOW WORD
	ADD	#1,(R1)+
	ADC	(R1)
	BIC	#177774,(R1)
	TST	-(R1)
	BIC	#177770,TIMTMP+4		;CLEAR ALL BUT BITS 1-3
	MOV	#TIMTMP,R0
	MOV	#EXVIRT!PRTOFF,$TADSP		;ADDRESS GIVEN IS EXEC VIRTUAL
	DPOSVR
	 BCC	C10XXX
C10CR1:	JMP	C10CER

.IF DF CLKASB
C10C6:	SETFLG				;ENABLE STORING TIME/DATE
	 TIMFLG
	JSR PC,RDCLK			;READ CLOCK INTO TIMTMP
.IIF NE EPTREL,	MOV #XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	DPOSVT
	  $DTTIME
	  TIMTMP
	 BCS C10CR1			;ERROR
	BR C10XXX

;FORMAT OF DTTIME PDP10 WORD IS:
;BYTE (5)DAY (2)0 (5)HOUR (2)0 (6)MINUTE (4)MONTH,YEAR (2)0 (6)SECOND

RDCLK:	PUSH R0
	PUSH R1
	PUSH R2
	PUSH R3
2$:	TSTB @$CLKST
	BPL 2$				;MAKE SURE CLOCK IS READY
	MOV @$CLKMD,R0
	MOV @$CLKHM,R1
	MOV @$CLKSEC,R2
	CMP @$CLKMD,R0
	BNE 2$
	CMP @$CLKHM,R1
	BNE 2$
	CMP @$CLKSEC,R2
	BNE 2$
	BIT #1400,R2			;TEST LOW TWO YEAR BITS
	BEQ 3$				;BRANCH IF A LEAP YEAR
	CMP R0,#2*400+29.		;IS IT FEB 29?
	BNE 3$				;NO
	MOV #3*400+1+100,@$CLKMD	;YES, SET TO MAR 1
	BR 2$
3$:	MOV R0,R3
	SL R3,4
	BIC #7777,R3			;LEAVE TOP 4 BITS (MONTH)
	BIS R3,R2			;MONTH/YEAR//SECONDS
	ROR R0
	BCC 1$
	BIS #100000,R1			;LOW BIT OF DAY
1$:	MOV #TIMTMP,R3
	MOV R2,(R3)+
	MOV R1,(R3)+
	BIC #177760,R0			;JUST KEEP LOW 4 BITS
	MOV R0,(R3)
	POP R3
	POP R2
	POP R1
	POP R0
	RTS PC

TCUINT:	RTI				;INT FROM SETTING CLOCK

.ENDC ;DF CLKASB

.ENDC ;SAILVR
;PDP-10 SWITCH REGISTER

$TENSW:	MOV	SWR,$$SWR	;GET PDP-11 SWITCHES
	MOV	$$SWR,$SWS10+2

	MOV	#$SWS10,R1	;POSITION FOR 0 TO 15 OF
	MOV	#4,R3		;PDP-10 SWITCH REGISTER
	PROL36

	MOV	#$SWS10+2,R4	;Bits 4:15 + xxxx of new stuff
	MOV	#SWS10+2,R5	;old switches.

	BIC	#17,(R4)	;CLEAR 16-19 FROM NEW
	BIC	#177760,(R5)	;CLEAR 4-15 FROM OLD

	BIS	(R4)+,(R5)+	;INSERT BITS 4-15

	BIC	#177760,(R4)	;CLEAR HI JUNK FROM NEW
	BIC	#17,(R5)	;CLEAR 0-3 FROM OLD

	BIS	(R4),(R5)	;INSERT BITS 0-3

	TSTB	TENRUN		;PDP-10 RUNNING ?
	BEQ	1$		;NO

.IF DF SAILVR
	TST	SWTDEP		;DID PDP-10 ASK FOR SWITCHES?
	BEQ	1$		;NO.  WELL, DON'T STORE UNTIL ASKED
.ENDC

.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	DPOSVT			;DEPOSIT PDP-10 SWITCH REGISTER
	  $DTSWR		;IN DTE20 COMM AREA
	  SWS10
	 BCS	2$		;ERROR
$TCX=.
1$:	EXIT
2$:	EXITERR			;RETURN

;PDP-10 LAST TYPED CHARACTER ROUTINE

$TENCHR:TSTB	TENRUN		;PDP-10 RUNNING ?
	BEQ	$TCX		;NO
	TST	TENTTY		;TTY DEPOSIT ALLOWED ?
	BEQ	$TCX		;NO
	PUSH	R0
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	DPOST			;YES, SEND LAST TYPED CHAR
	  $DTCHR
	  $TNCHR
	POP	R0
	BR	$TCX		;DON'T CARE IF FAILED
.SBTTL	PDP-10 PROGRAM COMMAND

P10CMD:	MOV	#-1,R0		;USE OUTPUT BUFFER
	PRGCMD			;& PROGRAM COMMAND
	 BCS	DIANF		;C-BIT SET, ERROR
	BR	DIAFND		;PASSED

.SBTTL	"DIAMON" FILE SELECTION AND READ ROUTINES

DIASEL:	MOV	#$INBUF,R1	;PUT "P" & "SPACE" FIRST
	MOV	#"P ,(R1)+	;IN CASE ACT10 LOAD
	MOV	#$OUTBF,R0	;TRANSFER "DIAMON" FILE.EXT
	MOV	R0,$OUTPT	;TO INPUT BUFFER
	JSR	PC,$DIASX
	MOV	#$INBUF+2,$INPTC ;SET PICKUP POINTER

	NAMEXT			;SETUP FILE NAME.EXT

	SETFLG
	  LDCNTL		;SET LOAD CONTROL TO HELP
	SETFLG
	  DIAFLG		;SET PROCESSING TO "DIAMON" MODE

	JMP	DEVFIL		;GO LOOKUP & READ FIRST ASCII LINE

;RETURN HERE WHEN FILE FOUND
DIAFND:	CLR	R0		;SET FOUND INDICATOR
$DIAFX:	JMP	C10TIX		;USE 10 TTY INPUT ROUTINE

;RETURN HERE WHEN FILE NOT FOUND
DIANF:	MOV	#-1,R0		;SET NOT FOUND INDICATOR
	BR	$DIAFX
;"DIAMON" FILE READ

DIARD:	JSR	PC,$TI36C	;CLEAR 36 BIT WORD STORAGE

	CMP	$INPTC,$INPTR	;ANY CURRENT INPUT ?
	BLE	DIARNL		;NO
1$:	JMP	ACTLD2		;GO READ NEXT INPUT LINE

DIARNL=.			;RETURN HERE WITH NEW LINE SETUP
2$:	MOV	#5,R2		;5 ASCII CHARS PER 36 BIT WORD

3$:	CMP	$INPTC,$INPTR	;EOL ?
	BGT	4$		;YES
	MOVB	@$INPTC,R0	;GET FILE LINE CHAR
	INC	$INPTC
	MOV	#7,R1
	JSR	PC,SHFT36	;SHIFT 36 BIT WORD LEFT 7
	BISB	R0,$DRAM	;INSERT NEW ASCII BYTE
	DEC	R2		;DONE 5 CHARS ?
	BGT	3$		;NOT YET

4$:	CLR	R1		;LEFT JUSTIFY FOR PDP-10 ASCII
	JSR	PC,SHFT36

.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	DPOSVT			;LOAD INTO FROM 11 WORD
	  $DTF11
	  $DRAM
	 BCC	6$		;OK

5$:	PMSG	<?DIAMON XFER>
	JMP	$CNTLC

DIAEOF=.			;DIAMON READ END-OF-FILE
.IIF NE EPTREL,	MOV	#XEPT!PRTOFF,$TADSP	;SET ADDR MODE FOR NEXT EXDEP
	D10MON			;SET FROM 11 WORD -1
	  $DTF11
	 BCS	5$		;ERROR

6$:	JMP	C10DON		;TELL 10 TO CONTINUE

.SBTTL	PDP-11 CONSOLE FUNCTIONS

;START PDP11 AT ADDRESS GIVEN

.SE:	TTISDL
	 BCS	2$		;NON-NUMBER

1$:	TTOCTE			;READ AN OCTAL ADDRESS

4$:	MOV	R0,SEADR	;GO TO ADDRESS IN R0
	JMP	SRT11

2$:	CMPB	#'D,R0		;"D", START DIAGNOSTIC
	BEQ	3$
	CMPB	#'C,R0		;"C", START CONSOLE
	BNE	$$CMDE
	MOV	#PRGSRT,R0
	BR	4$
3$:	MOV	#3000,R0
	BR	4$
;EXAMINE ELEVEN AT ADDRESS GIVEN

.EE:	MOV	#1,R5
	BR	.EEB

.EB:	CLR	R5

.EEB:	MOV	#.EADR,R2
	CLR	R3
	TTISDL
	 BCS	6$		;NON-NUMBER

	TTCOCT			;READ AN OCTAL ADDRESS

	MOV	R0,R1
	MOV	R0,(R2)		;SAVE ADR FOR DEPOSIT

	TTIBRK			;GET BREAK CHAR
	 BCS	$$PARA
	CMPB	#COMMA,R0
	BNE	2$
	INC	R3		;SET MULTIPLE PRINT FLAG
	PNORML
	TTCOCT			;GET LAST ADDRESS
	MOV	R0,R4		;SAVE END ADR

2$:	BIC	R5,R1		;IF WORD, MAKE EVEN
21$:	MOV	R1,R0
	MOV	R1,(R2)		;SAVE ADDRESS
	PNTOCT			;PRINT ADDRESS
	PSLASH

1$:	TST	R5		;BYTE ?
	BEQ	3$		;YES

	MOV	(R1),R0
	PNTOCT			;PRINT CONTENTS OF ADDRESS
	BR	4$

3$:	MOVB	(R1),R0
	BIC	#177400,R0
	PNTOCS			;PRINT BYTE CONTENTS
4$:	TST	R3
	BEQ	5$
	PCRLF
	CMP	R1,R4
	BHIS	5$
	INC	R1		;INCREMENT ADDRESS
	ADD	R5,R1		;IF WORD, INC BY 2
	BR	2$

5$:	PCRLF
	JMP	$KONSL

6$:	BEQ	7$		;UPARROW
	BVC	61$		;NONE
	INC	(R2)		;EXAMINE NEXT 11 ADDRESS
	ADD	R5,(R2)
61$:	MOV	(R2),R1
	INC	$INPTC		;ADVANCE PAST TERMINATOR
	BR	2$

7$:	DEC	(R2)
	SUB	R5,(R2)
	BR	61$

;ZERO ELEVEN

.ZE:	TTOCTE			;GET START ADDRESS
	MOV	R0,R5

	TTCOCT			;GET END ADDRESS

1$:	CLR	(R5)+		;ZERO 11
	CMP	R5,R0		;COMPLETED ?
	BLOS	1$		;NO
	JMP	$CONSL
;DEPOSIT ELEVEN DATA

.DE:	MOV	#1,R5		;DEPOSIT 11 WORD
	BR	.DEB

.DB:	CLR	R5		;DEPOSIT 11 BYTE

.DEB:	MOV	#.EADR,R2
	TTISDL
	 BCS	5$		;NON-NUMBER

	TTCOCT			;READ OCTAL ADDRESS

1$:	MOV	R0,R1
	TST	R5
	BEQ	2$
	BIT	R5,R0
	BNE	$$PARA		;WORD, ODD ADDRESSES ILLEGAL

2$:	TTISDL
	 BCS	$$CMDE
	TTCOCT			;GET DATA

	MOV	R1,(R2)

	TST	R5		;BYTE ?
	BEQ	3$

	MOV	R0,(R1)		;STOW IT
	BR	4$

3$:	MOVB	R0,(R1)		;STOW 11 BYTE
4$:	JMP	$KONSL

5$:	BVC	$$CMDE		;IF COLON, USE PREVIOUS EXAMINE ADDRESS
	MOV	(R2),R0
	BR	1$

$$PARA:	JMP	$PARA
$$CMDE:	JMP	$CMDE
.SBTTL	KL10 MONITOR & ACT10 COMMAND ROUTINES

$VERIFY:SETFLG
	  VERIFY
	PNORML
	CLR	LDOVRD		;CLEAR OVERRIDE
	BR	$PROG1

$LDT:	MOV	#1,LDOVRD	;LOAD TEN, OVERRIDE EXT
	BR	$PROG2
$LDE:	MOV	#2,LDOVRD	;LOAD ELEVEN, OVERRIDE EXT
	BR	$PROG2
$LDR:	MOV	#3,LDOVRD	;LOAD RAM, OVERRIDE EXT
	BR	$PROG2
$LDB:	MOV	#6,LDOVRD	;LOAD ELEVEN BIN, OVERRIDE EXT
	BR	$PROG2
$LDD:	MOV	#7,LDOVRD	;LOAD DSKDMP BOOTSTRAP INTO KLDCP,OVERRIDE EXT (D10)
	BR	$PROG2

$PROG:	CLR	LDOVRD		;CLEAR OVERRIDE
$PROG2:	CLR	VERIFY
$PROG1:	CLR	LDCNTL		;CLEAR LOAD CONTROL FLAG
	CLR	SRTFLG		;CLEAR SELF START FLAG
	CLRB	CONSOL-1	;OVERLAY INUSE INDICATOR
	BR	$HELP1		;GO LOAD PROGRAM

$JFILE:	SETFLG
	  JFILEF		;SET DOUBLE INDIRECT FLAG
	CLR	PRGRUN		;CLEAR PROGRAM RUNNING FLAG
	MOV	#TOUTBF+5000,IFINP	;SETUP STORAGE POINTER
	BR	$IIX

$IFILE:	MOV	#TOUTBF,IFINP	;SETUP STORAGE POINTER
$IIX:	CLR	PCMDFLG		;CLEAR PROGRAM COMMAND
	SETFLG
	  IFILEF		;SET INDIRECT FILE FLAG
	CLR	@IFINP		;CLEAR 1ST BUFFER WORD
	CLRB	CONSOL-1	;OVERLAY INUSE INDICATOR

$HELP:	CLR	LDOVRD		;CLEAR LOAD OVERRIDE FOR H,I,J
	SETFLG
	  LDCNTL		;SET LOAD CONTROL TO "HELP"
	PNORML
.IF DF MONASB
	TST	DEVTYP
	BPL	$HELP1
	JMP	ACTFIL		;ACT10 HELP
.ENDC
$HELP1:	JMP	DVLOAD		;RP04/DECTAPE/FLOPPY HELP
.IF DF MONASB
$AT:	TTITRM
	SETFLG
	  DEVTYP		;SET ACT10 MODE
	COMCLR			;CLEAR COMMUNICATIONS
	BR	$DTX
.ENDC

$DT:	CLR	FLOPPY
	TTISDL
	BCS	$DTC		;LETTER
	TTISDO			;GET UNIT SELECTION DIGIT
	CMP	R0,#7		;MUST BE 0 TO 7
	BGT	$CMDE
	SWAB	R0		;PUT IN PROPER PLACE FOR TC11
	MOV	R0,DTUNIT	;SAVE IT
$RXX:	CLR	DEVTYP		;SET DECTAPE MODE
$DTX:	JMP	$KONSL

.IF DF RXASB
$RX:	SETFLG
	  FLOPPY
	TTISDL
	  BCS	$DTC		;LETTER
	TTISDO			;GET SELECTION DIGIT
	CMP	R0,#1		;MUST BE EITHER 0 OR 1
	BGT	$CMDE
	BNE	1$
	MOV	#RXU1,R0
1$:	MOV	R0,RXUNIT	;SAVE FOR RX11/RX01 FLOPPY
	BR	$RXX
.ENDC ;IF DF RXASB

$DTC:
.IF DF UTLASB
	CMP	#"CO,$INBUF+2	;IS COMMAND 'DTCOPY'/'RXCOPY' ?
	BNE	1$
	CMP	#"PY,$INBUF+4
	BNE	1$
	JSR	PC,$KLUCK	;UTILITY IN CORE ?
	TST	FLOPPY
	BEQ	2$
	JMP	@RXCOPY		;FLOPPY COPY
2$:	JMP	@DTCOPY		;YES
.ENDC
1$:	JMP	$CMDER

$GO:	INC	$INPTC
$$GO:	MOV	PGOCTL,R0	;GO, START PROGRAM
	JMP	@LDSTRT(R0)

LDSTRT:	SRT11X
	SRT10

$JC:	TTITRM
	SETFLG			;SET J FILE FLAG TO CONTINUE
	  JFILEF		;INTERRUPTED J FILE PROCESS
	BR	$DTX
SRT11X:	MOV	PGOADR,SEADR
SRT11:	TST	SEADR
	BEQ	1$		;IF ADR 0, START AT 3000
	BIT	#1,SEADR
	BNE	ADRERR		;ODD ADDRESSES NOT ALLOWED

2$:	JSR	PC,$CMCLR	;CLEAR COMMON STORAGE

	CLR	IFILEF		;END INDIRECT PROCESS
	SETFLG
	  PRGRUN
	MOV	#STACK-2,R0	;PASS STACK BASE ADR IN R0
	MOV	R0,SP		;RESET STACK
	JMP	@SEADR		;START 11 PROGRAM AT LOAD ADDRESS

1$:	MOV	#3000,SEADR
	BR	2$

SRT10:	MOV	#TGOADR+2,R0
	MOV	#PGOADR+2,R1	;PUT LOAD ADR IN 10 GO ADR
	MOV	(R1),(R0)
	MOV	-(R1),-(R0)
	JMP	$$$ST		;GO TO 10 START ROUTINE

.LIF NDF MONASB
$COMNT:	JMP $CONSL
.IF DF MONASB

;ACT10 TIME REQUEST

$TIME:	TTBTRM
	TST	DEVTYP
	BPL	$TIME1		;ONLY LEGAL IN ACT10 MODE

	COMENQ			;REQUEST APT10 SERVICE

	MOV	#$INBUF,R0
	COMCMD			;SEND COMMAND

	$PMSG			;PRINT INPUT LINE
	CINBF
	COMCLR
$TIME3:	JMP	$CONSL

$TIME1:	JMP	NONACT		;NON ACT10

$LOGO:
$LOGIN:	TST	DEVTYP		;ONLY LEGAL IN ACT10 MODE
	BPL	$TIME1
	TTITRM

	COMENQ			;REQUEST SERVICE

	MOV	#$INBUF,R0
	COMCMD			;SEND COMMAND
	COMEOT
	BR	$TIME3

$COMNT:	TST	DEVTYP		;ACT10 MODE ?
	BPL	1$		;NO, LOCAL ONLY

	COMENQ			;REQUEST APT10 SERVICE

	MOV	#$INBUF,R0
	COMCMD			;SEND MESSAGE
	COMEOT

1$:	BR	$TIME3		;BACK TO CONSOLE

$BOOT:
$SCRPT:
$MSCP:
$GSCP:
$BOOTT:	JMP	$CMDER

.ENDC	;END .IF DF MONASB
ADRERR:	PMSG	<?ADR>
	BR	COMNER

$PARA:	PMSG	<?PARAM>
	BR	COMNER

$CMDE:	JMP	$CMDER

.IF DF MONASB
NONACT:	PMSG	<?ACT10>
	BR	COMNER

NORESP:	PMSG	<?RESPONSE>
.ENDC

COMNER:	JMP	$CNTLC

;REINITIALIZE SYSTEM

.RI:	CLR	$ONETM
	JMP	START
.SBTTL	LINE PRINTER SELECTION ROUTINE

.IF DF LPASB

$LPT:	PMSG	<LP, Y OR N ? - ←>
	TTILIN
	TTIYES
	 BCS	$LPT		;JUNK
	BMI	10$		;NO
	MOV	#NOLP,ERRVEC	;DO WE HAVE A LINE PRINTER CONTROLLER ?
	MOV	$LPS,R0
	TST	(R0)
	TST	R0
	BNE	1$		;LP11
	MOV	#LP20A,R0
	TST	(R0)
	TST	R0
	BNE	2$		;LP20A
	MOV	#LP20B,R0
	TST	(R0)
	TST	R0
	BNE	2$		;LP20B
	MOV	#$TIMOT,ERRVEC
	PMSG	<?NO LPT>
	JMP	$CNTLC
1$:	CLR	LPTYPE		;LP11 - TYPE = 0
	BR	3$
2$:	MOV	R0,LPTYPE	;LP20 - TYPE = CONTROLLER BASE ADDRESS
3$:	MOV	#$TIMOT,ERRVEC
	SETFLG
	  LPTFLG
	TST	LPTYPE
	BNE	5$
	TST	@$LPS		;LP11 - LPT OK ?
	BMI	20$		;NO
4$:	JMP	$CONSL

5$:	JSR	PC,LP20INI	;INITIALIZE LP20
	BCS	20$		;ERROR
	BR	4$
10$:	CLR	LPTFLG		;TURN OFF LINE PRINTER
	BR	4$
20$:	PMSG	<?LP ERR\>
	BR	$LPT

NOLP:	CLR	R0		;NO LP CONTROLLER BUS TRAP
	RTI

.SBTTL	LP20 INITIALIZATION ROUTINE

LP20INI:MOV	LPTYPE,R5	;SETUP BASE ADDRESS
	MOV	#LPLINI!LPRERR,(R5) ;CLEAR LP20
	MOV	#VFUDAT,R0	;SETUP VFU BUFFER
	MOV	R0,LPBSAD(R5)	;SETUP BUFFER ADDRESS
	MOV	#037756,(R0)+	;VFU LOAD CODE & ALL CHANS
	MOV	#77,(R0)+
	MOV	#100,R1		;SET FOR 64 LINES ON PAGE
1$:	CLR	(R0)+
	DEC	R1
	BNE	1$
	MOV	#167400,(R0)	;VFU STOP LOAD CODE
	MOV	#-206,LPBCTR(R5) ;206 BYTE XFER
	MOV	#LPVLOD!LPPENB!LPGO,(R5) ;VFU LOAD & GO
	JSR	PC,LP20DN	;WAIT FOR DONE
	BCS	3$		;ERROR

	CLR	LPCBUF(R5)	;CLEAR LP20 RAM
	MOV	#LPLINI!LPRERR,(R5)
	MOV	#-1000,R0	;LOCATION COUNT
	MOVB	#LPPENB,(R5)	;PARENB & NOT GO
2$:	CLR	LPRAMD(R5)	;CLEAR
	INC	LPCBUF(R5)	;INCREMENT ADDRESS
	INC	R0		;COUNT IT
	BNE	2$		;IF NOT DONE, GO BACK
	CLC			;COMPLETED, C-BIT CLEAR RETURN
	RTS	PC

3$:	SEC			;ERROR, C-BIT SET RETURN
	RTS	PC

.ENDC ;IF DF LPASB
.SBTTL	CONSOLE TELETYPE FUNCTIONS

$TP:	MOV	#$TPLIN,R5	;SET TTY PAGE LENGTH
	BR	$TPW

$TW:	MOV	#$PGWID,R5	;SET TTY PAGE WIDTH

$TPW:	TTISDL
	 BCS	$PARAM

	TTIDEC			;SPECIFIED IN DECIMAL
	 BCS	$DECN		;WASNT A DECIMAL NUMBER

	MOV	R0,(R5)		;SET IT UP

$TPWF:	JMP	$CONSL		;RETURN TO CONSOLE FOR NEXT COMMAND

;TTY FILL CHARACTER PARAMETER

$TF:	TTISDO

	CMP	R0,#5		;CHECK FILL PARAMETER UPPER LIMIT
	BGT	$FILPL

	MOV	R0,$TTYFL	;SET TTY FILL PARAMETER

	BR	$TPWF

;MESSAGES TO OPERATOR

$DECN:
$FILPL:
$OCTN:
$PARAM:	JMP	$PARA
.SBTTL	KLINIK FIELD SERVICE REMOTE DIAGNOSTICS ENABLE

.IF NDF TELASB

.KLINIK:CMP	#"IN,$INBUF+2
	BNE	2$
	CMP	#"IK,$INBUF+4
	BNE	2$

	TST	DL11EFLG		;PRESENTLY ENABLED ?
	BEQ	1$			;NO

KLUNK=.
	CLR	DL11EFLG		;YES, CLEAR IT
	PMSG	<KLINIK CLEARED>
	JMP	$CNTLC

1$:	CLR	@$FSTKS			;INITIALIZE
	BIS	#DLDTR!DLRTS,@$FSTKS	;SET DATA TERMINAL READY
	BIT	#DLCTS,@$FSTKS		;DO WE HAVE CLEAR TO SEND ?
	BEQ	FSDISC			;NO
	COM	DL11EFLG		;ENABLE KLINIK
	PMSG	<KLINIK ENABLED>
	JMP	$CNTLC

2$:	JMP	$CMDER

;DL11E DISCONNECT, CLEAR TO SEND NOT SET

FSDISC:	CLR	DL11EFLG
	PMSG	<\DL11E NOT CLR TO SEND, >
	BR	KLUNK

.ENDC ;IF NDF TELASB
;⊗ FSRLEN FSRINT FSINT1 FSXIT FSINT2 FSXITC FSINTA FSINT3 FSINT4 FSXITA FSIN4R FSIN4D FSIN4E FSIN4W HANGUP HANGU1 FSHNG1 FSINT5 FSIN5A FSTINT FSTYP FSTYP1 FSTYP2 FSCLKR FSMSG FSLOSM PWORD PWLEN $HU

.SBTTL	FIELD SERVICE TELETYPE INTERRUPT HANDLER

.IF DF TELASB

FSRLEN==10.		;10 CHARACTER FSRBUF

;TRAP HERE WHEN DATASET INTERRUPT OCCURS
FSRINT:	PUSH R0
	PUSH R1
	MOV @$FSTKS,R0		;GET THE STATUS
	MOV FSSTATE,R1
	BEQ FSINT1		;FIRST INTERRUPT
	JMP @R1

FSINT1:	BIT #DLRI,R0		;TEST FOR RING INDICATION
	BEQ FSXIT		;NOPE
	MOV #FSINT2,FSSTATE	;SET DISPATCH FOR NEXT INT
	MOV #60.,R0
	MOV #HANGU1,R1
	JSR PC,FSCLKR		;SET CLOCK REQUEST TO HANG UP IN ONE MINUTE
FSXIT:	POP R1
	POP R0
	RTT

FSINT2:	BIT #DLCD,R0		;TEST CARRIER DETECT
	BEQ FSXIT		;NOPE
	BIT #DLCTS,R0		;TEST CLEAR TO SEND
	BEQ FSXIT		;NOPE
	MOV #FSINTA,FSSTATE	;OK, HAVE BOTH
FSXITC:	TST @$FSTKB		;CLEAR INPUT DONE BY REFERENCING BUFFER
	BIS #DLRIE,@$FSTKS	;SET READER INTERRUPT ENABLE
	BR FSXIT		;wait now for user to type something

;here after user typed some character (any character)
FSINTA:	MOV #FSINT3,FSSTATE	;ignore input during type out
	MOV #FSMSG,R1
	JSR PC,FSTYP		;TYPE OUT GREETING MESSAGE
	MOV #FSRBUF,FSRPTR
	MOV #FSINT4,FSSTATE
	BR FSXITC		;wait for user to type char of password

FSINT3:	BIT #DLCTS,R0		;MAKE SURE WE HAVE CLEAR TO SEND
	BNE FSXIT
	BR HANGUP

FSINT4:	BIT #DLCTS,R0
	BEQ HANGUP		;HANGUP IF CLEAR TO SEND IS GONE
	BIT #DLRD,R0		;TEST INPUT DONE
	BEQ FSXIT		;SPURIOUS
	MOV @$FSTKB,R1		;GET THE CHARACTER
	BIC #177600,R1		;ignore parity
	CMP R1,#15
	BEQ FSIN4D		;Return is end of password
	CMP R1,#12
	BEQ FSIN4D		;Linefeed is end of password
	CMP R1,#177
	BEQ FSIN4R		;Rubout allows you to correct previous char
	CMP FSRPTR,#FSRBUF+FSRLEN
	BHIS FSXIT		;NO MORE ROOM
	MOVB R1,@FSRPTR		;STORE THE CHARACTER
	INC FSRPTR
FSXITA:	BR FSXIT

FSIN4R:	CMP FSRPTR,#FSRBUF
	BEQ FSXITA
	DEC FSRPTR
	BR FSXITA

FSIN4D:	BIC #DLRIE,@$FSTKS	;CLEAR RECEIVER INTERRUPT ENB
	MOV FSRPTR,R0
	SUB #FSRBUF,R0
	CMP R0,#PWLEN
	BNE FSIN4W		;TYPED WRONG AMOUNT
	MOV #FSRBUF,R0
	MOV #PWORD,R1
FSIN4E:	CMPB (R0)+,(R1)+
	BNE FSIN4W		;WRONG
	CMP R0,FSRPTR
	BLO FSIN4E		;MORE
	MOV #FSINT5,FSSTATE
	CLR FSCLKA		;FLUSH THE AUTO DESTRUCT CLOCK REQUEST
	INC FSFLG		;WIN
	BR FSXITA

FSIN4W:	MOV #FSLOSM,R1
	JSR PC,FSTYP
HANGUP:	JSR PC,HANGU1
	BR FSXITA

HANGU1:	MOV #DLRTS,@$FSTKS	;HANG UP DATASET (KEEP REQUEST TO SEND AS FLAG)
	CLR @$FSTPS		;FLUSH TYPEOUT
	CLR FSSTATE
	CLR FSFLG
	PUSH R0
	PUSH R1
	MOV #2,R0
	MOV #FSHNG1,R1
	JSR PC,FSCLKR		;PLANT FS CLOCK REQUEST FOR 2 SECONDS FROM NOW
	POP R1
	POP R0
	RTS PC

FSHNG1:	MOV #DLDTR!DLRTS!DLDIE,@$FSTKS	;REENABLE DATASET
	RTS PC

FSINT5:	BIT #DLCTS,R0
	BEQ FSIN5A
	BIT #DLCD,R0
	BEQ FSIN5A
	CLR FSCLKA		;FLUSH DESTRUCT SEQUENCE
	BR FSXITA

FSIN5A:	MOV #5.,R0		;START 5 SECOND TIMEOUT IF NO CLEAR TO SEND ...
	MOV #HANGU1,R1		; ... OR NO CARRIER DETECT
	JSR PC,FSCLKR		;PLANT AUTO DESTRUCT CLOCK REQUEST
	BR FSXITA

FSTINT:	PUSH R0
	PUSH R1
	TSTB @$FSTPS		;TEST TRANSMITTER READY
	BEQ FSXITA		;SPURIOUS INT
	MOV FSTPTR,R1
	BR FSTYP1

FSTYP:	CLR @$FSTPS		;CLEAR TRANSMITTER STATUS
	BIS #DLTIE,@$FSTPS	;SET TRANSMIT INTERRUPT ENABLE
	POP FSTYPR		;SAVE RETURN ADDRESS
FSTYP1:	MOVB (R1)+,R0		;GET NEXT CHARACTER
	BEQ FSTYP2		;END OF STRING
	MOV R0,@$FSTPB		;SEND CHARACTER
	MOV R1,FSTPTR		;SAVE POINTER TO TEXT
	BIT #DLCTS,@$FSTKS
	BEQ HANGUP
	BR FSXITA

FSTYP2:	CLR @$FSTPS		;CLEAR XMTR STATUS AGAIN
	JMP @FSTYPR		;RETURN TO CALLER

;CALL WITH # SECONDS IN R0, ADDRESS IN R1
FSCLKR:	PUSH R2
	PUSH R3
	PUSH R1
	MOV R0,R2		;CONVERT R0 TO 60THS
	CLR R1
.REPT 6
	ASL R1
	ASL R0
	ADC R1
.ENDR				;R1:R0 = 64 * ORIGINAL R0
	CLR R3
.REPT 2
	ASL R3
	ASL R2
	ADC R3
.ENDR				;R3:R2 = 4 * ORIGINAL R0
	SUB R2,R0
	SBC R1
	SUB R3,R1		;R1:R0 GETS 60 * ORIGINAL R0
	CLR R2
	ADD TIM11,R0
	ADC R1
	ADD TIM11+2,R1
	ADC R2
	ADD TIM11+4,R2		;R2:R1:R0 HAVE NEW TIME
	MOV #FSRTIM,R3		;STORE IN CLOCK REQUEST TIME WORDS
	MOV R0,(R3)+
	MOV R1,(R3)+
	MOV R2,(R3)
	POP FSCLKA
	POP R3
	POP R2
	RTS PC


FSMSG:	.ASCIZ /
WAITS password = /

FSLOSM:	.ASCIZ /
Wrong
/
PWORD:	;XLISTED OF COURSE
.XLIST
	.BYTE 50
	.BYTE 51
	.BYTE 54
	.BYTE 56
.LIST
PWLEN==.-PWORD
	.EVEN

;HU command to KLDCP
$HU:	TTITRM
	PMSG <\BYE\>
	JSR PC,HANGU1
	CLR $TTYFL		;CLEAR PADDING AMOUNT
	JMP $CONSL

.ENDC ;IF DF TELASB
